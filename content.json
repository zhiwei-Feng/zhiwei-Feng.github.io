{"pages":[{"title":"about","text":"1234program_lang = [&quot;Go&quot;, &quot;Python&quot;, &quot;Rust&quot;]interests = ['distributed system', 'microservice']contact_me = 'zhiwei.feng1995@gmail.com'university = 'Fudan University'","link":"/about/index.html"}],"posts":[{"title":"slice使用append的小坑","text":"今天在刷一道算法题的时候遇到了一个关于slice在使用append的小细节问题。这个算法题可以参考路径总和II。题意很简单，就是从一个二叉树中所有由根到叶子节点的路径中找到所有的满足路径和等于target的路径。 问题在参考官方题解的golang版本的时候，发现了有一段代码是我一开始没弄明白的。完整代码可参考 1234567891011121314151617181920func pathSum(root *TreeNode, targetSum int) (ans [][]int) { path := []int{} var dfs func(*TreeNode, int) dfs = func(root *TreeNode, left int) { if root == nil { return } left -= root.Val path = append(path, root.Val) defer func() { path = path[:len(path)-1] }() if left == 0 &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil { ans = append(ans, append([]int{}, path...)) return } dfs(root.Left, left) dfs(root.Right, left) } dfs(root, targetSum) return} 其中的ans = append(ans, append([]int{}, path...))则是我关注的地方，一开始我疑惑为什么不直接ans = append(ans, path))，但是实验证明结果会非常奇怪，比如对于这样一个例子我们想要的是[[5,4,11,2],[5,8,4,5]]，但是实际上是[[5,8,4,1],[5,8,4,1]]. 解析这里其实是我忘了golang中的slice底层实现如下图所示 12345type slice struct { array unsafe.Pointer len int cap int} 因此如果像ans = append(ans, path))这样做，其实在ans存放的是path这个slice，在后续代码运行中的改变会导致ans的结果改变，从而产生一个错误的结果。而ans = append(ans, append([]int{}, path...))则是在ans中存放了一个path的副本，且该副本不会被其他代码修改到。因此结果才是正确的。 一行代码就揭示golang中slice的本质~，真实妙啊。 REFERENCE[1] leetcode 113题[2] 深入解析 Go 中 Slice 底层实现","link":"/2021/04/22/be-careful-when-use-append-to-add-slice-to-slice/"},{"title":"面试16种代码模式总结(1) - 滑动窗口","text":"本系列文章是对Grokking the Coding Interview: Patterns for Coding Questions课程的总结，编程语言使用Go。读者如果想要更细致的了解，请自行购买课程学习。 问题背景在处理数组和链表的时候，我们经常会需要找出满足某些条件的连续子列, 比如子列的和最大等，这个时候就可以使用滑动窗口的思想来进行解答。这里注意的是子列可以是固定大小也可以是可变大小，两种情况有相应的处理方式。 下面先给出一个例子，比如在给定一个数组，找出其中每个size为K的连续子列的平均值。 123Array: [1, 3, 2, 6, -1, 4, 1, 8, 2], K=5Output: [2.2, 2.8, 2.4, 3.6, 2.8] 滑动窗口的解决方案如下: 123456789101112131415161718func findAveragesOfSubArraysBySlidingWindow(K int, arr []int) []float64 { results := make([]float64, len(arr)-K+1) windowSum := 0 windowStart := 0 for windowEnd := 0; windowEnd &lt; len(arr); windowEnd++ { // 把下个元素加上 windowSum += arr[windowEnd] // 滑动窗口，特别地，如果没有达到K个则不滑动 if windowEnd &gt;= K-1 { // 当前windowSum计算了整个窗口的和 results[windowStart] = float64(windowSum) / float64(K) // 当前窗口计算完后，移动窗口需要先减去原来窗口头部的元素 windowSum -= arr[windowStart] windowStart++ } } return results} 解法总结根据窗口大小是否固定，分为固定大小和可变大小 固定大小这里拿 找出size=k的最大连续子序列和 作为例子 12345678910Given an array of positive numbers and a positive number k,find the maximum sum of any contiguous subarray of size k.Input: [2, 1, 5, 1, 3, 2], k=3Output: 9Explanation: Subarray with maximum sum is [5, 1, 3].Input: [2, 3, 4, 1, 5], k=2Output: 7Explanation: Subarray with maximum sum is [3, 4]. 解决方案 123456789101112131415161718192021222324252627282930func max(x, y int) int { if x &gt; y { return x } else { return y }}func solution(arr []int, k int) int { var ( windowStart = 0 windowSum = 0 // 用于记录当前窗口的状态 maxSum = 0 // 用于记录最好的状态 ) for windowEnd:=0;windowEnd&lt;len(arr);windowEnd++{ // 这一步是窗口的右侧进行一格扩张，同时更新当前窗口的状态 windowSum += arr[windowEnd] // 判断当前窗口是否满足相应条件 if windowEnd &gt;= k-1{ // 更新最好的状态 maxSum = max(maxSum, windowSum) // 收缩窗口左侧 windowSum -= arr[windowStart] windowStart-- } } return maxSum} 相关练习: [1][2][3] 可变大小这里通过长度最小的子数组来说明 123456789101112131415161718192021222324252627282930313233343536373839404142func min(i, j int) int { if i&lt;j { return i }else{ return j }}func minSubArrayLen(target int, nums []int) int { var( windowStart = 0 windowSum = 0 minSize = -1 ) for windowEnd:=0;windowEnd&lt;len(nums);windowEnd++{ // 窗口右侧扩张，这个部分和固定大小是一样的 windowSum+=nums[windowEnd] // 这个部分是与固定大小类型最大的区别 // 不同于固定大小每次的右侧扩张和左侧收缩是同步的 // 可变大小的左侧收缩需要循环判断窗口是否满足条件 // 可能右侧扩张了很多次，但是左侧才收缩一回 // 也可能右侧扩张一次，左侧需要收缩几回 for windowSum&gt;=target{ if minSize==-1{ minSize = windowEnd-windowStart+1 }else{ minSize = min(minSize, windowEnd-windowStart+1) } windowSum-=nums[windowStart] windowStart++ } // 对于一些情况条件需要进行后处理，比如当收缩窗口直到窗口内单一字符数量&lt;k // 然后再比较当前窗口的大小 } if minSize==-1{ return 0 } return minSize} 相关练习题: [1][2][3][4][5][6][7] 特殊例子最小覆盖子串原题见leetcode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func findSubstring(str, pattern string) string { // 边界 if len(pattern)&gt;len(str){ return &quot;&quot; } var ( windowStart = 0 matched = 0 minLength = len(str) + 1 subStrStart = 0 patternMap = make(map[byte]int) ) for i := 0; i &lt; len(pattern); i++ { patternMap[pattern[i]]++ } for windowEnd := 0; windowEnd &lt; len(str); windowEnd++ { wright := str[windowEnd] if _, ok := patternMap[wright]; ok { patternMap[wright]-- // 关键点1, 不再是==0，而是&gt;=0，因为包含所有的字符 if patternMap[wright] &gt;= 0 { matched++ } } // 如果当前window包含pattern所有的字符，则从左收缩窗口至不完全包含状态 // 注意这里等号右侧不是len(patternMap)，因为是要匹配所有字符 for matched == len(pattern) { if minLength &gt; windowEnd-windowStart+1 { minLength = windowEnd - windowStart + 1 subStrStart = windowStart } wleft := str[windowStart] if _, ok := patternMap[wleft]; ok { // 关键点2，只要有一个匹配的字符移除了窗口，则停止收缩 if patternMap[wleft] == 0 { matched-- } patternMap[wleft]++ } windowStart++ } } if minLength &gt; len(str) { return &quot;&quot; } else { return str[subStrStart : subStrStart+minLength] }} FAQ: 这里对上述代码做一定的解释，主要困惑点在于两个关键点Q: 为什么关键点1处是&gt;=0？A: 因为是要匹配所有的字符，因为每遇到一个需要匹配的字符，我们都需要对patternMap中对应值做减法并matched++, 直到我们匹配完了pattern所有该字符，此时对于多余该字符我们只需要更新patternMap，但是不必再更新matched。 Q: 为什么关键点2处是==0？A: 这里注意，如果窗口同一个字符没有冗余，那么移除了一个该字符则意味着匹配不完全，但是如果窗口内该字符有冗余，比如pattern是aab，而窗口内有3个a，此时a有冗余，如果收缩窗口只移出了一个a，那么此时窗口依然是满足匹配完全条件的，反映到代码上，收缩前patternMap['a'] = -1 (在2的基础-3)，收缩后patternMap['a']=0，因此如果收缩掉下一个a，则需要matched–了。 串联所有单词的子串原题见leetcode这个题目主要要对题意理解清楚，首先目标子串需要满足几个条件： 长度等于单词列表中的每个单词长度*单词个数 子串不可以出现不在列表上的其他单词 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func findWordConcatenation(str string, words []string) []int { if len(words)==0||len(str)==0{ return []int{} } var ( wordFreqMap = make(map[string]int) wordsCount = len(words) wordLength = len(words[0]) // 存储满足条件的index startIndex = make([]int, 0, 10) ) // 记录每个单词出现的频率 for _, v := range words { wordFreqMap[v]++ } // 注意这个不是常规的sliding window pattern // i表示的是一个子串的起始位置，从条件可知每个子串是固定长度的 // 所以i最大为len(str)-wordLength*wordsCount for i := 0; i &lt;= len(str)-wordLength*wordsCount; i++ { wordsSeenMap := make(map[string]int) // key1: 保存看过的word的数量 // 对从当前index i开始的长度为wordLength*wordsCount的string进行判定 for j := 0; j &lt; wordsCount; j++ { nextWordIndex := i + j*wordLength // 当前word的开始index word := str[nextWordIndex : nextWordIndex+wordLength] // 如果出现不在words数组中的word，则直接跳出 if _, ok := wordFreqMap[word]; !ok { break } wordsSeenMap[word]++ // 如果words数组中某个word数量出现次数过多意味着一定会有其他单词不在，则也直接跳出 if wordsSeenMap[word] &gt; wordFreqMap[word] { break } // 如果遍历到该string的最后一个字符都没跳出循环，意味该string是满足条件的 if j == wordsCount-1 { startIndex = append(startIndex, i) } } // ===end=== } return startIndex} REFERENCE[1] https://www.educative.io/courses/grokking-the-coding-interview[2] https://github.com/zhiwei-Feng/Golang-Grokking-the-Coding-Interview-Patterns-for-Coding-Questions","link":"/2021/04/04/sliding-window/"},{"title":"从6.824的kv.go理解tcp协议","text":"本文是在学习6.824课程时，对Lec 2的kv.go产生的困惑的解释和总结。 kv.go首先对kv.go的情况进行解释。这里只会取一些重点片段进行解释，需要\b了解完整代码细节的，读者可自行选择文章最后的参考条目进行详细了解。 主逻辑12345678910func main() { //启动rpc服务，一个kv存储 server() //写入一个kv键值对 put(&quot;subject&quot;, &quot;6.824&quot;) fmt.Printf(&quot;Put(subject, 6.824) done\\n&quot;) //读出刚才存储的key的value fmt.Printf(&quot;get(subject) -&gt; %s\\n&quot;, get(&quot;subject&quot;))} 主逻辑非常简单，启动一个kv存储的rpc服务，然后运行简单的读写功能测试。 server()123456789101112131415161718192021func server() { kv := new(KV) kv.data = map[string]string{} rpcs := rpc.NewServer() rpcs.Register(kv) l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;) if e != nil { log.Fatal(&quot;listen error:&quot;, e) } go func() { for { conn, err := l.Accept() if err == nil { go rpcs.ServeConn(conn) } else { break } } l.Close() }()} 启动服务，监听1234端口，并开始接受客户端的连接 client12345678910111213141516171819202122func get(key string) string { client := connect() args := GetArgs{key} reply := GetReply{} err := client.Call(&quot;KV.Get&quot;, &amp;args, &amp;reply) if err != nil { log.Fatal(&quot;error:&quot;, err) } client.Close() return reply.Value}func put(key string, val string) { client := connect() args := PutArgs{key, val} reply := PutReply{} err := client.Call(&quot;KV.Put&quot;, &amp;args, &amp;reply) if err != nil { log.Fatal(&quot;error:&quot;, err) } client.Close()} 客户端方法总体逻辑是一致，首先进行tcp连接的建立，然后进行rpc方法调用，最后关闭连接 解析过程如果你运行该程序，会发现打印如下： 12345$ go run kv.goPut(subject, 6.824) doneget(subject) -&gt; 6.824$ 为什么程序最后会退出，而不是因为server在监听阻塞住。我自己的解释是：首先是因为server()中的无限接收请求的循环是运行在goroutine当中，所以之后的客户端请求可以并发的运行；其次因为主线程没有其他方法的阻塞，所以会在所有逻辑结束后退出，也意味该进程退出了，这样其中的所有线程都会结束，包括其中创建的goroutine。 如果读者有更好的解释欢迎留言讨论。 在该程序的主逻辑中，实际发生了两次tcp连接，我们知道一次tcp协议的运行过程有三个阶段：连接创建、数据传送和连接终止。server()下开启的rpc服务监听着1234端口，而get和put()中的connect()则完成一次tcp连接创建的三次握手，如图下 此时通过netstat命令查看会出现有两个连接以及一个监听 当数据传送完毕，get和put()调用Close()方法进入连接终止阶段（四次握手）后，客户端状态则会进入TIME_WAIT状态 等待2MSL后，客户端Close。 如果希望对TCP的设计想要更深入了解，可以参考 为什么 TCP 协议有 TIME_WAIT 状态 为什么 TCP 建立连接需要三次握手 Why is the TCP connection terminated in a 4-way handshake? REFERENCE[1] 6.824 kv.go[2] 维基百科","link":"/2021/04/11/socket-analysis-for-6-824-kv-go/"},{"title":"两种翻转slice的方式对比","text":"刷题时，遇到一个需求如下：对一个slice进行翻转。在实现的过程使用了两种方式： 每次插入新元素时，使用append左插入的方式 先正常append右插入，最后再对这个slice进行翻转 两种方式的实现及时间和空间消耗的对比实现下面两个方法实现的功能是一致的 方法1使用左插入法来实现翻转，如下所示 123456789101112func method1() { result := make([][]int, 0) for i := 0; i &lt; 100; i++ { item := make([]int, 0) for j := 0; j &lt; 10; j++ { item = append(item, i*j) } // 左插入 join := [][]int{item} result = append(join, result...) }} 方法2先正常append，再翻转 123456789101112131415func method2() { result := make([][]int, 0) for i := 0; i &lt; 100; i++ { item := make([]int, 0) for j := 0; j &lt; 10; j++ { item = append(item, i*j) } result = append(result, item) } tmp := result result = make([][]int, 0) for i := len(tmp) - 1; i &gt;= 0; i-- { result = append(result, tmp[i]) }} 性能对比 时间 1234goos: darwingoarch: amd64BenchmarkMethod1-4 17006 69558 ns/opBenchmarkMethod2-4 43002 27851 ns/op 时间上，方法2要好于方法1 空间 空间上，方法2也要优于方法1 分析通过pprof工具对其源码进行分析如下 从上图我们发现，result = append(join, result...)语句的内存消耗非常严重，同时这种方法进行append，会使得地址重新分配（因为首地址改变了）致使多余内存和时间的消耗。 补充方法2的翻转可以有两种方法实现 如上面所示，通过slice反向遍历插入完成翻转 还可以通过双指针法来翻转 这里通过一个简单例子比较下双方的性能 123456789101112131415161718192021222324func method1() { var input = make([]int, 0, 100) for i := 0; i &lt; len(input); i++ { input = append(input, i) } // method1 for i := 0; i &lt; len(input); i++ { j := len(input) - 1 - i input[i], input[j] = input[j], input[j] }}func method2() { var input = make([]int, 0, 100) for i := 0; i &lt; len(input); i++ { input = append(input, i) } // method2 tmp := input input = make([]int, 0, 100) for i := len(tmp) - 1; i &gt;= 0; i-- { input = append(input, tmp[i]) }} 结果表示，双指针法会更好一些，理由很简单，因为双指针是O(N/2)的 1234goos: darwingoarch: amd64BenchmarkMethod1-4 64120593 17.6 ns/op BenchmarkMethod2-4 29222400 40.8 ns/op 结论这种情况下推荐使用方法2，同时对于方法1(左插入)的使用要格外谨慎，不当的使用会使得程序的时/空间消耗加剧。 如果有更好的实现方式，或者对上述程序有更好的建议，欢迎下方评论~","link":"/2021/04/16/two-way-to-reverse-slice/"}],"tags":[{"name":"go","slug":"go","link":"/tags/go/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"sliding window","slug":"sliding-window","link":"/tags/sliding-window/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"}],"categories":[{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"面试","slug":"面试","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"16种代码模式","slug":"面试/16种代码模式","link":"/categories/%E9%9D%A2%E8%AF%95/16%E7%A7%8D%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%BC%8F/"}]}