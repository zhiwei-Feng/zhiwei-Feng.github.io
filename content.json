{"pages":[{"title":"about","text":"å…³äºæˆ‘æ­£åœ¨æ”»è¯»è®¡ç®—æœºç¡•å£«ï¼Œä¸»è¦ç ”ç©¶$\\mathtt{Video\\ Object\\ Segmentation}$ ä¸è¿‡AIå¯¹æˆ‘æ¥è¯´è¿˜æ˜¯å¤ªç„å­¦äº†ï¼Œæˆ‘é€‰æ‹©è€å®æå¼€å‘ğŸ˜‘ |Program Lang| = Go/Python|Contact Me| = zhiwei.feng1995@gmail.com|University| = Fudan University|å…´è¶£| = ä¸­é—´ä»¶/åˆ†å¸ƒå¼/å¾®æœåŠ¡/äº‘åŸç”Ÿ/åŸºç¡€æ¶æ„","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/04/03/hello-world/"},{"title":"é¢è¯•16ç§ä»£ç æ¨¡å¼æ€»ç»“(1) - æ»‘åŠ¨çª—å£","text":"æœ¬ç³»åˆ—æ–‡ç« æ˜¯å¯¹Grokking the Coding Interview: Patterns for Coding Questionsè¯¾ç¨‹çš„æ€»ç»“ï¼Œç¼–ç¨‹è¯­è¨€ä½¿ç”¨Goã€‚è¯»è€…å¦‚æœæƒ³è¦æ›´ç»†è‡´çš„äº†è§£ï¼Œè¯·è‡ªè¡Œè´­ä¹°è¯¾ç¨‹å­¦ä¹ ã€‚ é—®é¢˜èƒŒæ™¯åœ¨å¤„ç†æ•°ç»„å’Œé“¾è¡¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šéœ€è¦æ‰¾å‡ºæ»¡è¶³æŸäº›æ¡ä»¶çš„è¿ç»­å­åˆ—, æ¯”å¦‚å­åˆ—çš„å’Œæœ€å¤§ç­‰ï¼Œè¿™ä¸ªæ—¶å€™å°±å¯ä»¥ä½¿ç”¨æ»‘åŠ¨çª—å£çš„æ€æƒ³æ¥è¿›è¡Œè§£ç­”ã€‚è¿™é‡Œæ³¨æ„çš„æ˜¯å­åˆ—å¯ä»¥æ˜¯å›ºå®šå¤§å°ä¹Ÿå¯ä»¥æ˜¯å¯å˜å¤§å°ï¼Œä¸¤ç§æƒ…å†µæœ‰ç›¸åº”çš„å¤„ç†æ–¹å¼ã€‚ ä¸‹é¢å…ˆç»™å‡ºä¸€ä¸ªä¾‹å­ï¼Œæ¯”å¦‚åœ¨ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ‰¾å‡ºå…¶ä¸­æ¯ä¸ªsizeä¸ºKçš„è¿ç»­å­åˆ—çš„å¹³å‡å€¼ã€‚ 123Array: [1, 3, 2, 6, -1, 4, 1, 8, 2], K=5Output: [2.2, 2.8, 2.4, 3.6, 2.8] æ»‘åŠ¨çª—å£çš„è§£å†³æ–¹æ¡ˆå¦‚ä¸‹: 123456789101112131415161718func findAveragesOfSubArraysBySlidingWindow(K int, arr []int) []float64 { results := make([]float64, len(arr)-K+1) windowSum := 0 windowStart := 0 for windowEnd := 0; windowEnd &lt; len(arr); windowEnd++ { // æŠŠä¸‹ä¸ªå…ƒç´ åŠ ä¸Š windowSum += arr[windowEnd] // æ»‘åŠ¨çª—å£ï¼Œç‰¹åˆ«åœ°ï¼Œå¦‚æœæ²¡æœ‰è¾¾åˆ°Kä¸ªåˆ™ä¸æ»‘åŠ¨ if windowEnd &gt;= K-1 { // å½“å‰windowSumè®¡ç®—äº†æ•´ä¸ªçª—å£çš„å’Œ results[windowStart] = float64(windowSum) / float64(K) // å½“å‰çª—å£è®¡ç®—å®Œåï¼Œç§»åŠ¨çª—å£éœ€è¦å…ˆå‡å»åŸæ¥çª—å£å¤´éƒ¨çš„å…ƒç´  windowSum -= arr[windowStart] windowStart++ } } return results} è§£æ³•æ€»ç»“æ ¹æ®çª—å£å¤§å°æ˜¯å¦å›ºå®šï¼Œåˆ†ä¸ºå›ºå®šå¤§å°å’Œå¯å˜å¤§å° å›ºå®šå¤§å°è¿™é‡Œæ‹¿ æ‰¾å‡ºsize=kçš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œ ä½œä¸ºä¾‹å­ 12345678910Given an array of positive numbers and a positive number k,find the maximum sum of any contiguous subarray of size k.Input: [2, 1, 5, 1, 3, 2], k=3Output: 9Explanation: Subarray with maximum sum is [5, 1, 3].Input: [2, 3, 4, 1, 5], k=2Output: 7Explanation: Subarray with maximum sum is [3, 4]. è§£å†³æ–¹æ¡ˆ 123456789101112131415161718192021222324252627282930func max(x, y int) int { if x &gt; y { return x } else { return y }}func solution(arr []int, k int) int { var ( windowStart = 0 windowSum = 0 // ç”¨äºè®°å½•å½“å‰çª—å£çš„çŠ¶æ€ maxSum = 0 // ç”¨äºè®°å½•æœ€å¥½çš„çŠ¶æ€ ) for windowEnd:=0;windowEnd&lt;len(arr);windowEnd++{ // è¿™ä¸€æ­¥æ˜¯çª—å£çš„å³ä¾§è¿›è¡Œä¸€æ ¼æ‰©å¼ ï¼ŒåŒæ—¶æ›´æ–°å½“å‰çª—å£çš„çŠ¶æ€ windowSum += arr[windowEnd] // åˆ¤æ–­å½“å‰çª—å£æ˜¯å¦æ»¡è¶³ç›¸åº”æ¡ä»¶ if windowEnd &gt;= k-1{ // æ›´æ–°æœ€å¥½çš„çŠ¶æ€ maxSum = max(maxSum, windowSum) // æ”¶ç¼©çª—å£å·¦ä¾§ windowSum -= arr[windowStart] windowStart-- } } return maxSum} ç›¸å…³ç»ƒä¹ : [1][2][3] å¯å˜å¤§å°è¿™é‡Œé€šè¿‡é•¿åº¦æœ€å°çš„å­æ•°ç»„æ¥è¯´æ˜ 123456789101112131415161718192021222324252627282930313233343536373839404142func min(i, j int) int { if i&lt;j { return i }else{ return j }}func minSubArrayLen(target int, nums []int) int { var( windowStart = 0 windowSum = 0 minSize = -1 ) for windowEnd:=0;windowEnd&lt;len(nums);windowEnd++{ // çª—å£å³ä¾§æ‰©å¼ ï¼Œè¿™ä¸ªéƒ¨åˆ†å’Œå›ºå®šå¤§å°æ˜¯ä¸€æ ·çš„ windowSum+=nums[windowEnd] // è¿™ä¸ªéƒ¨åˆ†æ˜¯ä¸å›ºå®šå¤§å°ç±»å‹æœ€å¤§çš„åŒºåˆ« // ä¸åŒäºå›ºå®šå¤§å°æ¯æ¬¡çš„å³ä¾§æ‰©å¼ å’Œå·¦ä¾§æ”¶ç¼©æ˜¯åŒæ­¥çš„ // å¯å˜å¤§å°çš„å·¦ä¾§æ”¶ç¼©éœ€è¦å¾ªç¯åˆ¤æ–­çª—å£æ˜¯å¦æ»¡è¶³æ¡ä»¶ // å¯èƒ½å³ä¾§æ‰©å¼ äº†å¾ˆå¤šæ¬¡ï¼Œä½†æ˜¯å·¦ä¾§æ‰æ”¶ç¼©ä¸€å› // ä¹Ÿå¯èƒ½å³ä¾§æ‰©å¼ ä¸€æ¬¡ï¼Œå·¦ä¾§éœ€è¦æ”¶ç¼©å‡ å› for windowSum&gt;=target{ if minSize==-1{ minSize = windowEnd-windowStart+1 }else{ minSize = min(minSize, windowEnd-windowStart+1) } windowSum-=nums[windowStart] windowStart++ } // å¯¹äºä¸€äº›æƒ…å†µæ¡ä»¶éœ€è¦è¿›è¡Œåå¤„ç†ï¼Œæ¯”å¦‚å½“æ”¶ç¼©çª—å£ç›´åˆ°çª—å£å†…å•ä¸€å­—ç¬¦æ•°é‡&lt;k // ç„¶åå†æ¯”è¾ƒå½“å‰çª—å£çš„å¤§å° } if minSize==-1{ return 0 } return minSize} ç›¸å…³ç»ƒä¹ é¢˜: [1][2][3][4][5][6][7] ç‰¹æ®Šä¾‹å­æœ€å°è¦†ç›–å­ä¸²åŸé¢˜è§leetcode 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func findSubstring(str, pattern string) string { // è¾¹ç•Œ if len(pattern)&gt;len(str){ return &quot;&quot; } var ( windowStart = 0 matched = 0 minLength = len(str) + 1 subStrStart = 0 patternMap = make(map[byte]int) ) for i := 0; i &lt; len(pattern); i++ { patternMap[pattern[i]]++ } for windowEnd := 0; windowEnd &lt; len(str); windowEnd++ { wright := str[windowEnd] if _, ok := patternMap[wright]; ok { patternMap[wright]-- // å…³é”®ç‚¹1, ä¸å†æ˜¯==0ï¼Œè€Œæ˜¯&gt;=0ï¼Œå› ä¸ºåŒ…å«æ‰€æœ‰çš„å­—ç¬¦ if patternMap[wright] &gt;= 0 { matched++ } } // å¦‚æœå½“å‰windowåŒ…å«patternæ‰€æœ‰çš„å­—ç¬¦ï¼Œåˆ™ä»å·¦æ”¶ç¼©çª—å£è‡³ä¸å®Œå…¨åŒ…å«çŠ¶æ€ // æ³¨æ„è¿™é‡Œç­‰å·å³ä¾§ä¸æ˜¯len(patternMap)ï¼Œå› ä¸ºæ˜¯è¦åŒ¹é…æ‰€æœ‰å­—ç¬¦ for matched == len(pattern) { if minLength &gt; windowEnd-windowStart+1 { minLength = windowEnd - windowStart + 1 subStrStart = windowStart } wleft := str[windowStart] if _, ok := patternMap[wleft]; ok { // å…³é”®ç‚¹2ï¼Œåªè¦æœ‰ä¸€ä¸ªåŒ¹é…çš„å­—ç¬¦ç§»é™¤äº†çª—å£ï¼Œåˆ™åœæ­¢æ”¶ç¼© if patternMap[wleft] == 0 { matched-- } patternMap[wleft]++ } windowStart++ } } if minLength &gt; len(str) { return &quot;&quot; } else { return str[subStrStart : subStrStart+minLength] }} FAQ: è¿™é‡Œå¯¹ä¸Šè¿°ä»£ç åšä¸€å®šçš„è§£é‡Šï¼Œä¸»è¦å›°æƒ‘ç‚¹åœ¨äºä¸¤ä¸ªå…³é”®ç‚¹Q: ä¸ºä»€ä¹ˆå…³é”®ç‚¹1å¤„æ˜¯&gt;=0ï¼ŸA: å› ä¸ºæ˜¯è¦åŒ¹é…æ‰€æœ‰çš„å­—ç¬¦ï¼Œå› ä¸ºæ¯é‡åˆ°ä¸€ä¸ªéœ€è¦åŒ¹é…çš„å­—ç¬¦ï¼Œæˆ‘ä»¬éƒ½éœ€è¦å¯¹patternMapä¸­å¯¹åº”å€¼åšå‡æ³•å¹¶matched++, ç›´åˆ°æˆ‘ä»¬åŒ¹é…å®Œäº†patternæ‰€æœ‰è¯¥å­—ç¬¦ï¼Œæ­¤æ—¶å¯¹äºå¤šä½™è¯¥å­—ç¬¦æˆ‘ä»¬åªéœ€è¦æ›´æ–°patternMapï¼Œä½†æ˜¯ä¸å¿…å†æ›´æ–°matchedã€‚ Q: ä¸ºä»€ä¹ˆå…³é”®ç‚¹2å¤„æ˜¯==0ï¼ŸA: è¿™é‡Œæ³¨æ„ï¼Œå¦‚æœçª—å£åŒä¸€ä¸ªå­—ç¬¦æ²¡æœ‰å†—ä½™ï¼Œé‚£ä¹ˆç§»é™¤äº†ä¸€ä¸ªè¯¥å­—ç¬¦åˆ™æ„å‘³ç€åŒ¹é…ä¸å®Œå…¨ï¼Œä½†æ˜¯å¦‚æœçª—å£å†…è¯¥å­—ç¬¦æœ‰å†—ä½™ï¼Œæ¯”å¦‚patternæ˜¯aabï¼Œè€Œçª—å£å†…æœ‰3ä¸ªaï¼Œæ­¤æ—¶aæœ‰å†—ä½™ï¼Œå¦‚æœæ”¶ç¼©çª—å£åªç§»å‡ºäº†ä¸€ä¸ªaï¼Œé‚£ä¹ˆæ­¤æ—¶çª—å£ä¾ç„¶æ˜¯æ»¡è¶³åŒ¹é…å®Œå…¨æ¡ä»¶çš„ï¼Œåæ˜ åˆ°ä»£ç ä¸Šï¼Œæ”¶ç¼©å‰patternMap['a'] = -1 (åœ¨2çš„åŸºç¡€-3)ï¼Œæ”¶ç¼©åpatternMap['a']=0ï¼Œå› æ­¤å¦‚æœæ”¶ç¼©æ‰ä¸‹ä¸€ä¸ªaï¼Œåˆ™éœ€è¦matchedâ€“äº†ã€‚ ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²åŸé¢˜è§leetcodeè¿™ä¸ªé¢˜ç›®ä¸»è¦è¦å¯¹é¢˜æ„ç†è§£æ¸…æ¥šï¼Œé¦–å…ˆç›®æ ‡å­ä¸²éœ€è¦æ»¡è¶³å‡ ä¸ªæ¡ä»¶ï¼š é•¿åº¦ç­‰äºå•è¯åˆ—è¡¨ä¸­çš„æ¯ä¸ªå•è¯é•¿åº¦*å•è¯ä¸ªæ•° å­ä¸²ä¸å¯ä»¥å‡ºç°ä¸åœ¨åˆ—è¡¨ä¸Šçš„å…¶ä»–å•è¯ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849func findWordConcatenation(str string, words []string) []int { if len(words)==0||len(str)==0{ return []int{} } var ( wordFreqMap = make(map[string]int) wordsCount = len(words) wordLength = len(words[0]) // å­˜å‚¨æ»¡è¶³æ¡ä»¶çš„index startIndex = make([]int, 0, 10) ) // è®°å½•æ¯ä¸ªå•è¯å‡ºç°çš„é¢‘ç‡ for _, v := range words { wordFreqMap[v]++ } // æ³¨æ„è¿™ä¸ªä¸æ˜¯å¸¸è§„çš„sliding window pattern // i è¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªå­ä¸²çš„èµ·å§‹ä½ç½®ï¼Œä»æ¡ä»¶å¯çŸ¥æ¯ä¸ªå­ä¸²æ˜¯å›ºå®šé•¿åº¦çš„ // æ‰€ä»¥iæœ€å¤§ä¸ºlen(str)-wordLength*wordsCount for i := 0; i &lt;= len(str)-wordLength*wordsCount; i++ { wordsSeenMap := make(map[string]int) // key1: ä¿å­˜çœ‹è¿‡çš„wordçš„æ•°é‡ // å¯¹ä»å½“å‰index iå¼€å§‹çš„é•¿åº¦ä¸ºwordLength*wordsCountçš„stringè¿›è¡Œåˆ¤å®š for j := 0; j &lt; wordsCount; j++ { nextWordIndex := i + j*wordLength // å½“å‰wordçš„å¼€å§‹index word := str[nextWordIndex : nextWordIndex+wordLength] // å¦‚æœå‡ºç°ä¸åœ¨wordsæ•°ç»„ä¸­çš„wordï¼Œåˆ™ç›´æ¥è·³å‡º if _, ok := wordFreqMap[word]; !ok { break } wordsSeenMap[word]++ // å¦‚æœwordsæ•°ç»„ä¸­æŸä¸ªwordæ•°é‡å‡ºç°æ¬¡æ•°è¿‡å¤šæ„å‘³ç€ä¸€å®šä¼šæœ‰å…¶ä»–å•è¯ä¸åœ¨ï¼Œåˆ™ä¹Ÿç›´æ¥è·³å‡º if wordsSeenMap[word] &gt; wordFreqMap[word] { break } // å¦‚æœéå†åˆ°è¯¥stringçš„æœ€åä¸€ä¸ªå­—ç¬¦éƒ½æ²¡è·³å‡ºå¾ªç¯ï¼Œæ„å‘³è¯¥stringæ˜¯æ»¡è¶³æ¡ä»¶çš„ if j == wordsCount-1 { startIndex = append(startIndex, i) } } // ===end=== } return startIndex} REFERENCE[1] https://www.educative.io/courses/grokking-the-coding-interview[2] https://github.com/zhiwei-Feng/Golang-Grokking-the-Coding-Interview-Patterns-for-Coding-Questions","link":"/2021/04/04/sliding-window/"}],"tags":[{"name":"hello","slug":"hello","link":"/tags/hello/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"sliding window","slug":"sliding-window","link":"/tags/sliding-window/"},{"name":"go","slug":"go","link":"/tags/go/"}],"categories":[{"name":"hello","slug":"hello","link":"/categories/hello/"},{"name":"é¢è¯•","slug":"é¢è¯•","link":"/categories/%E9%9D%A2%E8%AF%95/"},{"name":"16ç§ä»£ç æ¨¡å¼","slug":"é¢è¯•/16ç§ä»£ç æ¨¡å¼","link":"/categories/%E9%9D%A2%E8%AF%95/16%E7%A7%8D%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%BC%8F/"}]}