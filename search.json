[{"title":"sliceä½¿ç”¨appendçš„å°å‘","url":"/2021/04/22/be-careful-when-use-append-to-add-slice-to-slice/","content":"ä»Šå¤©åœ¨åˆ·ä¸€é“ç®—æ³•é¢˜çš„æ—¶å€™é‡åˆ°äº†ä¸€ä¸ªå…³äºsliceåœ¨ä½¿ç”¨appendçš„å°ç»†èŠ‚é—®é¢˜ã€‚è¿™ä¸ªç®—æ³•é¢˜å¯ä»¥å‚è€ƒè·¯å¾„æ€»å’ŒIIã€‚é¢˜æ„å¾ˆç®€å•ï¼Œå°±æ˜¯ä»ä¸€ä¸ªäºŒå‰æ ‘ä¸­æ‰€æœ‰ç”±æ ¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸­æ‰¾åˆ°æ‰€æœ‰çš„æ»¡è¶³è·¯å¾„å’Œç­‰äºtargetçš„è·¯å¾„ã€‚\n\n\né—®é¢˜åœ¨å‚è€ƒå®˜æ–¹é¢˜è§£çš„golangç‰ˆæœ¬çš„æ—¶å€™ï¼Œå‘ç°äº†æœ‰ä¸€æ®µä»£ç æ˜¯æˆ‘ä¸€å¼€å§‹æ²¡å¼„æ˜ç™½çš„ã€‚å®Œæ•´ä»£ç å¯å‚è€ƒ\nfunc pathSum(root *TreeNode, targetSum int) (ans [][]int) &#123;    path := []int&#123;&#125;    var dfs func(*TreeNode, int)    dfs = func(root *TreeNode, left int) &#123;        if root == nil &#123;            return        &#125;        left -= root.Val        path = append(path, root.Val)        defer func() &#123; path = path[:len(path)-1] &#125;()        if left == 0 &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil &#123;            ans = append(ans, append([]int&#123;&#125;, path...))            return        &#125;        dfs(root.Left, left)        dfs(root.Right, left)    &#125;    dfs(root, targetSum)    return&#125;\nå…¶ä¸­çš„ans = append(ans, append([]int&#123;&#125;, path...))åˆ™æ˜¯æˆ‘å…³æ³¨çš„åœ°æ–¹ï¼Œä¸€å¼€å§‹æˆ‘ç–‘æƒ‘ä¸ºä»€ä¹ˆä¸ç›´æ¥ans = append(ans, path))ï¼Œä½†æ˜¯å®éªŒè¯æ˜ç»“æœä¼šéå¸¸å¥‡æ€ªï¼Œæ¯”å¦‚å¯¹äºè¿™æ ·ä¸€ä¸ªä¾‹å­æˆ‘ä»¬æƒ³è¦çš„æ˜¯[[5,4,11,2],[5,8,4,5]]ï¼Œä½†æ˜¯å®é™…ä¸Šæ˜¯[[5,8,4,1],[5,8,4,1]].  \nè§£æè¿™é‡Œå…¶å®æ˜¯æˆ‘å¿˜äº†golangä¸­çš„sliceåº•å±‚å®ç°å¦‚ä¸‹å›¾æ‰€ç¤º\ntype slice struct &#123;    array unsafe.Pointer    len   int    cap   int&#125;\nå› æ­¤å¦‚æœåƒans = append(ans, path))è¿™æ ·åšï¼Œå…¶å®åœ¨anså­˜æ”¾çš„æ˜¯pathè¿™ä¸ªsliceï¼Œåœ¨åç»­ä»£ç è¿è¡Œä¸­çš„æ”¹å˜ä¼šå¯¼è‡´ansçš„ç»“æœæ”¹å˜ï¼Œä»è€Œäº§ç”Ÿä¸€ä¸ªé”™è¯¯çš„ç»“æœã€‚è€Œans = append(ans, append([]int&#123;&#125;, path...))åˆ™æ˜¯åœ¨ansä¸­å­˜æ”¾äº†ä¸€ä¸ªpathçš„å‰¯æœ¬ï¼Œä¸”è¯¥å‰¯æœ¬ä¸ä¼šè¢«å…¶ä»–ä»£ç ä¿®æ”¹åˆ°ã€‚å› æ­¤ç»“æœæ‰æ˜¯æ­£ç¡®çš„ã€‚\n\nä¸€è¡Œä»£ç å°±æ­ç¤ºgolangä¸­sliceçš„æœ¬è´¨~ï¼ŒçœŸå®å¦™å•Šã€‚\n\nREFERENCE[1] leetcode 113é¢˜[2] æ·±å…¥è§£æ Go ä¸­ Slice åº•å±‚å®ç°\n","categories":["Golang"],"tags":["go","æŒ‡é’ˆ"]},{"title":"GormåŠ æ‚²è§‚é”çš„æœ€æ–°ç”¨æ³•","url":"/2021/11/30/gorm-for-update/","content":"å› ä¸ºgoogleäº†â€œgorm for updateâ€æˆ–è€…æ˜¯â€œgorm å¼€å¯æ’ä»–é”â€å‡ºæ¥çš„æ–‡ç« æ¸…ä¸€è‰²çš„ä½¿ç”¨ç€å¦‚ä¸‹ç”¨æ³•æ¥å¼€å¯è¡¨çš„è¡Œ/è¡¨é”  \ntx.Set(&quot;gorm:query_option&quot;, &quot;FOR UPDATE&quot;).First(&amp;employee, id)\n\nä½†æ˜¯ç»è¿‡æµ‹è¯•ï¼Œæˆ‘åŠ äº†æ²¡æœ‰ä½œç”¨ï¼Œæœç´¢gormå®˜æ–¹æ–‡æ¡£ï¼Œç»“æœç”¨æ³•å·²ç»å˜æˆå¦‚ä¸‹\ndb.Clauses(clause.Locking&#123;Strength: &quot;UPDATE&quot;&#125;).Find(&amp;users)// SELECT * FROM `users` FOR UPDATEdb.Clauses(clause.Locking&#123;  Strength: &quot;SHARE&quot;,  Table: clause.Table&#123;Name: clause.CurrentTable&#125;,&#125;).Find(&amp;users)// SELECT * FROM `users` FOR SHARE OF `users`\n\næœç„¶æœ‰é—®é¢˜å…ˆæ‰¾å®˜æ–¹æ–‡æ¡£ã€‚ğŸ˜‚\n","categories":["Golang"],"tags":["go","gorm"]},{"title":"é¢è¯•16ç§ä»£ç æ¨¡å¼æ€»ç»“(1) - æ»‘åŠ¨çª—å£","url":"/2021/04/04/sliding-window/","content":"æœ¬ç³»åˆ—æ–‡ç« æ˜¯å¯¹Grokking the Coding Interview: Patterns for Coding Questionsè¯¾ç¨‹çš„æ€»ç»“ï¼Œç¼–ç¨‹è¯­è¨€ä½¿ç”¨Goã€‚è¯»è€…å¦‚æœæƒ³è¦æ›´ç»†è‡´çš„äº†è§£ï¼Œè¯·è‡ªè¡Œè´­ä¹°è¯¾ç¨‹å­¦ä¹ ã€‚\né—®é¢˜èƒŒæ™¯åœ¨å¤„ç†æ•°ç»„å’Œé“¾è¡¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šéœ€è¦æ‰¾å‡ºæ»¡è¶³æŸäº›æ¡ä»¶çš„è¿ç»­å­åˆ—, æ¯”å¦‚å­åˆ—çš„å’Œæœ€å¤§ç­‰ï¼Œè¿™ä¸ªæ—¶å€™å°±å¯ä»¥ä½¿ç”¨æ»‘åŠ¨çª—å£çš„æ€æƒ³æ¥è¿›è¡Œè§£ç­”ã€‚è¿™é‡Œæ³¨æ„çš„æ˜¯å­åˆ—å¯ä»¥æ˜¯å›ºå®šå¤§å°ä¹Ÿå¯ä»¥æ˜¯å¯å˜å¤§å°ï¼Œä¸¤ç§æƒ…å†µæœ‰ç›¸åº”çš„å¤„ç†æ–¹å¼ã€‚\n\n\nä¸‹é¢å…ˆç»™å‡ºä¸€ä¸ªä¾‹å­ï¼Œæ¯”å¦‚åœ¨ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œæ‰¾å‡ºå…¶ä¸­æ¯ä¸ªsizeä¸ºKçš„è¿ç»­å­åˆ—çš„å¹³å‡å€¼ã€‚  \nArray: [1, 3, 2, 6, -1, 4, 1, 8, 2], K=5Output: [2.2, 2.8, 2.4, 3.6, 2.8]\n\næ»‘åŠ¨çª—å£çš„è§£å†³æ–¹æ¡ˆå¦‚ä¸‹:\nfunc findAveragesOfSubArraysBySlidingWindow(K int, arr []int) []float64 &#123;    results := make([]float64, len(arr)-K+1)    windowSum := 0    windowStart := 0    for windowEnd := 0; windowEnd &lt; len(arr); windowEnd++ &#123;        // æŠŠä¸‹ä¸ªå…ƒç´ åŠ ä¸Š        windowSum += arr[windowEnd]        // æ»‘åŠ¨çª—å£ï¼Œç‰¹åˆ«åœ°ï¼Œå¦‚æœæ²¡æœ‰è¾¾åˆ°Kä¸ªåˆ™ä¸æ»‘åŠ¨        if windowEnd &gt;= K-1 &#123;            // å½“å‰windowSumè®¡ç®—äº†æ•´ä¸ªçª—å£çš„å’Œ            results[windowStart] = float64(windowSum) / float64(K)            // å½“å‰çª—å£è®¡ç®—å®Œåï¼Œç§»åŠ¨çª—å£éœ€è¦å…ˆå‡å»åŸæ¥çª—å£å¤´éƒ¨çš„å…ƒç´             windowSum -= arr[windowStart]            windowStart++        &#125;    &#125;    return results&#125;\n\nè§£æ³•æ€»ç»“æ ¹æ®çª—å£å¤§å°æ˜¯å¦å›ºå®šï¼Œåˆ†ä¸ºå›ºå®šå¤§å°å’Œå¯å˜å¤§å°\nå›ºå®šå¤§å°è¿™é‡Œæ‹¿ æ‰¾å‡ºsize=kçš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œ ä½œä¸ºä¾‹å­\nGiven an array of positive numbers and a positive number k,find the maximum sum of any contiguous subarray of size k.Input: [2, 1, 5, 1, 3, 2], k=3Output: 9Explanation: Subarray with maximum sum is [5, 1, 3].Input: [2, 3, 4, 1, 5], k=2Output: 7Explanation: Subarray with maximum sum is [3, 4].\n\nè§£å†³æ–¹æ¡ˆ\nfunc max(x, y int) int &#123;    if x &gt; y &#123;        return x    &#125; else &#123;        return y    &#125;&#125;func solution(arr []int, k int) int &#123;    var (        windowStart = 0        windowSum = 0 // ç”¨äºè®°å½•å½“å‰çª—å£çš„çŠ¶æ€        maxSum = 0 // ç”¨äºè®°å½•æœ€å¥½çš„çŠ¶æ€    )    for windowEnd:=0;windowEnd&lt;len(arr);windowEnd++&#123;        // è¿™ä¸€æ­¥æ˜¯çª—å£çš„å³ä¾§è¿›è¡Œä¸€æ ¼æ‰©å¼ ï¼ŒåŒæ—¶æ›´æ–°å½“å‰çª—å£çš„çŠ¶æ€        windowSum += arr[windowEnd]        // åˆ¤æ–­å½“å‰çª—å£æ˜¯å¦æ»¡è¶³ç›¸åº”æ¡ä»¶        if windowEnd &gt;= k-1&#123;            // æ›´æ–°æœ€å¥½çš„çŠ¶æ€            maxSum = max(maxSum, windowSum)            // æ”¶ç¼©çª—å£å·¦ä¾§            windowSum -= arr[windowStart]            windowStart--        &#125;    &#125;    return maxSum&#125;\n\n\nç›¸å…³ç»ƒä¹ : [1][2][3]\n\nå¯å˜å¤§å°è¿™é‡Œé€šè¿‡é•¿åº¦æœ€å°çš„å­æ•°ç»„æ¥è¯´æ˜\nfunc min(i, j int) int &#123;    if i&lt;j &#123;        return i    &#125;else&#123;        return j    &#125;&#125;func minSubArrayLen(target int, nums []int) int &#123;    var(        windowStart = 0        windowSum = 0        minSize = -1    )    for windowEnd:=0;windowEnd&lt;len(nums);windowEnd++&#123;        // çª—å£å³ä¾§æ‰©å¼ ï¼Œè¿™ä¸ªéƒ¨åˆ†å’Œå›ºå®šå¤§å°æ˜¯ä¸€æ ·çš„        windowSum+=nums[windowEnd]        // è¿™ä¸ªéƒ¨åˆ†æ˜¯ä¸å›ºå®šå¤§å°ç±»å‹æœ€å¤§çš„åŒºåˆ«        // ä¸åŒäºå›ºå®šå¤§å°æ¯æ¬¡çš„å³ä¾§æ‰©å¼ å’Œå·¦ä¾§æ”¶ç¼©æ˜¯åŒæ­¥çš„        // å¯å˜å¤§å°çš„å·¦ä¾§æ”¶ç¼©éœ€è¦å¾ªç¯åˆ¤æ–­çª—å£æ˜¯å¦æ»¡è¶³æ¡ä»¶        // å¯èƒ½å³ä¾§æ‰©å¼ äº†å¾ˆå¤šæ¬¡ï¼Œä½†æ˜¯å·¦ä¾§æ‰æ”¶ç¼©ä¸€å›        // ä¹Ÿå¯èƒ½å³ä¾§æ‰©å¼ ä¸€æ¬¡ï¼Œå·¦ä¾§éœ€è¦æ”¶ç¼©å‡ å›        for windowSum&gt;=target&#123;            if minSize==-1&#123;                minSize = windowEnd-windowStart+1            &#125;else&#123;                minSize = min(minSize, windowEnd-windowStart+1)            &#125;             windowSum-=nums[windowStart]            windowStart++        &#125;        // å¯¹äºä¸€äº›æƒ…å†µæ¡ä»¶éœ€è¦è¿›è¡Œåå¤„ç†ï¼Œæ¯”å¦‚å½“æ”¶ç¼©çª—å£ç›´åˆ°çª—å£å†…å•ä¸€å­—ç¬¦æ•°é‡&lt;k        // ç„¶åå†æ¯”è¾ƒå½“å‰çª—å£çš„å¤§å°    &#125;    if minSize==-1&#123;        return 0    &#125;    return minSize&#125;\n\n\nç›¸å…³ç»ƒä¹ é¢˜: [1][2][3][4][5][6][7]\n\nç‰¹æ®Šä¾‹å­æœ€å°è¦†ç›–å­ä¸²åŸé¢˜è§leetcode\nfunc findSubstring(str, pattern string) string &#123;    // è¾¹ç•Œ     if len(pattern)&gt;len(str)&#123;        return &quot;&quot;    &#125;    var (        windowStart = 0        matched     = 0        minLength   = len(str) + 1        subStrStart = 0        patternMap  = make(map[byte]int)    )    for i := 0; i &lt; len(pattern); i++ &#123;        patternMap[pattern[i]]++    &#125;    for windowEnd := 0; windowEnd &lt; len(str); windowEnd++ &#123;        wright := str[windowEnd]        if _, ok := patternMap[wright]; ok &#123;            patternMap[wright]--             // å…³é”®ç‚¹1, ä¸å†æ˜¯==0ï¼Œè€Œæ˜¯&gt;=0ï¼Œå› ä¸ºåŒ…å«æ‰€æœ‰çš„å­—ç¬¦            if patternMap[wright] &gt;= 0 &#123;                matched++            &#125;        &#125;        // å¦‚æœå½“å‰windowåŒ…å«patternæ‰€æœ‰çš„å­—ç¬¦ï¼Œåˆ™ä»å·¦æ”¶ç¼©çª—å£è‡³ä¸å®Œå…¨åŒ…å«çŠ¶æ€         // æ³¨æ„è¿™é‡Œç­‰å·å³ä¾§ä¸æ˜¯len(patternMap)ï¼Œå› ä¸ºæ˜¯è¦åŒ¹é…æ‰€æœ‰å­—ç¬¦        for matched == len(pattern) &#123;             if minLength &gt; windowEnd-windowStart+1 &#123;                minLength = windowEnd - windowStart + 1                subStrStart = windowStart            &#125;            wleft := str[windowStart]            if _, ok := patternMap[wleft]; ok &#123;                // å…³é”®ç‚¹2ï¼Œåªè¦æœ‰ä¸€ä¸ªåŒ¹é…çš„å­—ç¬¦ç§»é™¤äº†çª—å£ï¼Œåˆ™åœæ­¢æ”¶ç¼©                if patternMap[wleft] == 0 &#123;                    matched--                &#125;                patternMap[wleft]++            &#125;            windowStart++        &#125;    &#125;    if minLength &gt; len(str) &#123;        return &quot;&quot;    &#125; else &#123;        return str[subStrStart : subStrStart+minLength]    &#125;&#125;\nFAQ: è¿™é‡Œå¯¹ä¸Šè¿°ä»£ç åšä¸€å®šçš„è§£é‡Šï¼Œä¸»è¦å›°æƒ‘ç‚¹åœ¨äºä¸¤ä¸ªå…³é”®ç‚¹Q: ä¸ºä»€ä¹ˆå…³é”®ç‚¹1å¤„æ˜¯&gt;=0ï¼ŸA: å› ä¸ºæ˜¯è¦åŒ¹é…æ‰€æœ‰çš„å­—ç¬¦ï¼Œå› ä¸ºæ¯é‡åˆ°ä¸€ä¸ªéœ€è¦åŒ¹é…çš„å­—ç¬¦ï¼Œæˆ‘ä»¬éƒ½éœ€è¦å¯¹patternMapä¸­å¯¹åº”å€¼åšå‡æ³•å¹¶matched++, ç›´åˆ°æˆ‘ä»¬åŒ¹é…å®Œäº†patternæ‰€æœ‰è¯¥å­—ç¬¦ï¼Œæ­¤æ—¶å¯¹äºå¤šä½™è¯¥å­—ç¬¦æˆ‘ä»¬åªéœ€è¦æ›´æ–°patternMapï¼Œä½†æ˜¯ä¸å¿…å†æ›´æ–°matchedã€‚\nQ: ä¸ºä»€ä¹ˆå…³é”®ç‚¹2å¤„æ˜¯==0ï¼ŸA: è¿™é‡Œæ³¨æ„ï¼Œå¦‚æœçª—å£åŒä¸€ä¸ªå­—ç¬¦æ²¡æœ‰å†—ä½™ï¼Œé‚£ä¹ˆç§»é™¤äº†ä¸€ä¸ªè¯¥å­—ç¬¦åˆ™æ„å‘³ç€åŒ¹é…ä¸å®Œå…¨ï¼Œä½†æ˜¯å¦‚æœçª—å£å†…è¯¥å­—ç¬¦æœ‰å†—ä½™ï¼Œæ¯”å¦‚patternæ˜¯aabï¼Œè€Œçª—å£å†…æœ‰3ä¸ªaï¼Œæ­¤æ—¶aæœ‰å†—ä½™ï¼Œå¦‚æœæ”¶ç¼©çª—å£åªç§»å‡ºäº†ä¸€ä¸ªaï¼Œé‚£ä¹ˆæ­¤æ—¶çª—å£ä¾ç„¶æ˜¯æ»¡è¶³åŒ¹é…å®Œå…¨æ¡ä»¶çš„ï¼Œåæ˜ åˆ°ä»£ç ä¸Šï¼Œæ”¶ç¼©å‰patternMap[&#39;a&#39;] = -1 (åœ¨2çš„åŸºç¡€-3)ï¼Œæ”¶ç¼©åpatternMap[&#39;a&#39;]=0ï¼Œå› æ­¤å¦‚æœæ”¶ç¼©æ‰ä¸‹ä¸€ä¸ªaï¼Œåˆ™éœ€è¦matchedâ€“äº†ã€‚\nä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²åŸé¢˜è§leetcodeè¿™ä¸ªé¢˜ç›®ä¸»è¦è¦å¯¹é¢˜æ„ç†è§£æ¸…æ¥šï¼Œé¦–å…ˆç›®æ ‡å­ä¸²éœ€è¦æ»¡è¶³å‡ ä¸ªæ¡ä»¶ï¼š\n\né•¿åº¦ç­‰äºå•è¯åˆ—è¡¨ä¸­çš„æ¯ä¸ªå•è¯é•¿åº¦*å•è¯ä¸ªæ•°\nå­ä¸²ä¸å¯ä»¥å‡ºç°ä¸åœ¨åˆ—è¡¨ä¸Šçš„å…¶ä»–å•è¯\n\nfunc findWordConcatenation(str string, words []string) []int &#123;    if len(words)==0||len(str)==0&#123;        return []int&#123;&#125;    &#125;    var (        wordFreqMap = make(map[string]int)        wordsCount  = len(words)        wordLength  = len(words[0])        // å­˜å‚¨æ»¡è¶³æ¡ä»¶çš„index        startIndex  = make([]int, 0, 10)     )    // è®°å½•æ¯ä¸ªå•è¯å‡ºç°çš„é¢‘ç‡    for _, v := range words &#123;        wordFreqMap[v]++    &#125;    // æ³¨æ„è¿™ä¸ªä¸æ˜¯å¸¸è§„çš„sliding window pattern     // iè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªå­ä¸²çš„èµ·å§‹ä½ç½®ï¼Œä»æ¡ä»¶å¯çŸ¥æ¯ä¸ªå­ä¸²æ˜¯å›ºå®šé•¿åº¦çš„     // æ‰€ä»¥iæœ€å¤§ä¸ºlen(str)-wordLength*wordsCount    for i := 0; i &lt;= len(str)-wordLength*wordsCount; i++ &#123;        wordsSeenMap := make(map[string]int) // key1: ä¿å­˜çœ‹è¿‡çš„wordçš„æ•°é‡        // å¯¹ä»å½“å‰index iå¼€å§‹çš„é•¿åº¦ä¸ºwordLength*wordsCountçš„stringè¿›è¡Œåˆ¤å®š        for j := 0; j &lt; wordsCount; j++ &#123;            nextWordIndex := i + j*wordLength // å½“å‰wordçš„å¼€å§‹index            word := str[nextWordIndex : nextWordIndex+wordLength]            // å¦‚æœå‡ºç°ä¸åœ¨wordsæ•°ç»„ä¸­çš„wordï¼Œåˆ™ç›´æ¥è·³å‡º            if _, ok := wordFreqMap[word]; !ok &#123;                break            &#125;            wordsSeenMap[word]++             // å¦‚æœwordsæ•°ç»„ä¸­æŸä¸ªwordæ•°é‡å‡ºç°æ¬¡æ•°è¿‡å¤šæ„å‘³ç€ä¸€å®šä¼šæœ‰å…¶ä»–å•è¯ä¸åœ¨ï¼Œåˆ™ä¹Ÿç›´æ¥è·³å‡º            if wordsSeenMap[word] &gt; wordFreqMap[word] &#123;                break            &#125;            // å¦‚æœéå†åˆ°è¯¥stringçš„æœ€åä¸€ä¸ªå­—ç¬¦éƒ½æ²¡è·³å‡ºå¾ªç¯ï¼Œæ„å‘³è¯¥stringæ˜¯æ»¡è¶³æ¡ä»¶çš„            if j == wordsCount-1 &#123;                startIndex = append(startIndex, i)            &#125;        &#125;        // ===end===    &#125;    return startIndex&#125;\n\n\nREFERENCE[1] https://www.educative.io/courses/grokking-the-coding-interview[2] https://github.com/zhiwei-Feng/Golang-Grokking-the-Coding-Interview-Patterns-for-Coding-Questions\n","categories":["é¢è¯•","16ç§ä»£ç æ¨¡å¼"],"tags":["go","algorithm","sliding window"]},{"title":"ä»6.824çš„kv.goç†è§£tcpåè®®","url":"/2021/04/11/socket-analysis-for-6-824-kv-go/","content":"æœ¬æ–‡æ˜¯åœ¨å­¦ä¹ 6.824è¯¾ç¨‹æ—¶ï¼Œå¯¹Lec 2çš„kv.goäº§ç”Ÿçš„å›°æƒ‘çš„è§£é‡Šå’Œæ€»ç»“ã€‚\n\n\nkv.goé¦–å…ˆå¯¹kv.goçš„æƒ…å†µè¿›è¡Œè§£é‡Šã€‚è¿™é‡Œåªä¼šå–ä¸€äº›é‡ç‚¹ç‰‡æ®µè¿›è¡Œè§£é‡Šï¼Œéœ€è¦\bäº†è§£å®Œæ•´ä»£ç ç»†èŠ‚çš„ï¼Œè¯»è€…å¯è‡ªè¡Œé€‰æ‹©æ–‡ç« æœ€åçš„å‚è€ƒæ¡ç›®è¿›è¡Œè¯¦ç»†äº†è§£ã€‚\nä¸»é€»è¾‘func main() &#123;    //å¯åŠ¨rpcæœåŠ¡ï¼Œä¸€ä¸ªkvå­˜å‚¨    server()     //å†™å…¥ä¸€ä¸ªkvé”®å€¼å¯¹    put(&quot;subject&quot;, &quot;6.824&quot;)    fmt.Printf(&quot;Put(subject, 6.824) done\\n&quot;)    //è¯»å‡ºåˆšæ‰å­˜å‚¨çš„keyçš„value    fmt.Printf(&quot;get(subject) -&gt; %s\\n&quot;, get(&quot;subject&quot;))&#125;\nä¸»é€»è¾‘éå¸¸ç®€å•ï¼Œå¯åŠ¨ä¸€ä¸ªkvå­˜å‚¨çš„rpcæœåŠ¡ï¼Œç„¶åè¿è¡Œç®€å•çš„è¯»å†™åŠŸèƒ½æµ‹è¯•ã€‚\nserver()func server() &#123;    kv := new(KV)    kv.data = map[string]string&#123;&#125;    rpcs := rpc.NewServer()    rpcs.Register(kv)    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)    if e != nil &#123;        log.Fatal(&quot;listen error:&quot;, e)    &#125;    go func() &#123;        for &#123;            conn, err := l.Accept()            if err == nil &#123;                go rpcs.ServeConn(conn)            &#125; else &#123;                break            &#125;        &#125;        l.Close()    &#125;()&#125;\nå¯åŠ¨æœåŠ¡ï¼Œç›‘å¬1234ç«¯å£ï¼Œå¹¶å¼€å§‹æ¥å—å®¢æˆ·ç«¯çš„è¿æ¥\nclientfunc get(key string) string &#123;    client := connect()    args := GetArgs&#123;key&#125;    reply := GetReply&#123;&#125;    err := client.Call(&quot;KV.Get&quot;, &amp;args, &amp;reply)    if err != nil &#123;        log.Fatal(&quot;error:&quot;, err)    &#125;    client.Close()    return reply.Value&#125;func put(key string, val string) &#123;    client := connect()    args := PutArgs&#123;key, val&#125;    reply := PutReply&#123;&#125;    err := client.Call(&quot;KV.Put&quot;, &amp;args, &amp;reply)    if err != nil &#123;        log.Fatal(&quot;error:&quot;, err)    &#125;    client.Close()&#125;\nå®¢æˆ·ç«¯æ–¹æ³•æ€»ä½“é€»è¾‘æ˜¯ä¸€è‡´ï¼Œé¦–å…ˆè¿›è¡Œtcpè¿æ¥çš„å»ºç«‹ï¼Œç„¶åè¿›è¡Œrpcæ–¹æ³•è°ƒç”¨ï¼Œæœ€åå…³é—­è¿æ¥\nè§£æè¿‡ç¨‹å¦‚æœä½ è¿è¡Œè¯¥ç¨‹åºï¼Œä¼šå‘ç°æ‰“å°å¦‚ä¸‹ï¼š\n$ go run kv.goPut(subject, 6.824) doneget(subject) -&gt; 6.824$\n\nä¸ºä»€ä¹ˆç¨‹åºæœ€åä¼šé€€å‡ºï¼Œè€Œä¸æ˜¯å› ä¸ºserveråœ¨ç›‘å¬é˜»å¡ä½ã€‚æˆ‘è‡ªå·±çš„è§£é‡Šæ˜¯ï¼šé¦–å…ˆæ˜¯å› ä¸ºserver()ä¸­çš„æ— é™æ¥æ”¶è¯·æ±‚çš„å¾ªç¯æ˜¯è¿è¡Œåœ¨goroutineå½“ä¸­ï¼Œæ‰€ä»¥ä¹‹åçš„å®¢æˆ·ç«¯è¯·æ±‚å¯ä»¥å¹¶å‘çš„è¿è¡Œï¼›å…¶æ¬¡å› ä¸ºä¸»çº¿ç¨‹æ²¡æœ‰å…¶ä»–æ–¹æ³•çš„é˜»å¡ï¼Œæ‰€ä»¥ä¼šåœ¨æ‰€æœ‰é€»è¾‘ç»“æŸåé€€å‡ºï¼Œä¹Ÿæ„å‘³è¯¥è¿›ç¨‹é€€å‡ºäº†ï¼Œè¿™æ ·å…¶ä¸­çš„æ‰€æœ‰çº¿ç¨‹éƒ½ä¼šç»“æŸï¼ŒåŒ…æ‹¬å…¶ä¸­åˆ›å»ºçš„goroutineã€‚\nå¦‚æœè¯»è€…æœ‰æ›´å¥½çš„è§£é‡Šæ¬¢è¿ç•™è¨€è®¨è®ºã€‚\n\nåœ¨è¯¥ç¨‹åºçš„ä¸»é€»è¾‘ä¸­ï¼Œå®é™…å‘ç”Ÿäº†ä¸¤æ¬¡tcpè¿æ¥ï¼Œæˆ‘ä»¬çŸ¥é“ä¸€æ¬¡tcpåè®®çš„è¿è¡Œè¿‡ç¨‹æœ‰ä¸‰ä¸ªé˜¶æ®µï¼šè¿æ¥åˆ›å»ºã€æ•°æ®ä¼ é€å’Œè¿æ¥ç»ˆæ­¢ã€‚server()ä¸‹å¼€å¯çš„rpcæœåŠ¡ç›‘å¬ç€1234ç«¯å£ï¼Œè€Œgetå’Œput()ä¸­çš„connect()åˆ™å®Œæˆä¸€æ¬¡tcpè¿æ¥åˆ›å»ºçš„ä¸‰æ¬¡æ¡æ‰‹ï¼Œå¦‚å›¾ä¸‹\n\næ­¤æ—¶é€šè¿‡netstatå‘½ä»¤æŸ¥çœ‹ä¼šå‡ºç°æœ‰ä¸¤ä¸ªè¿æ¥ä»¥åŠä¸€ä¸ªç›‘å¬  \n\nå½“æ•°æ®ä¼ é€å®Œæ¯•ï¼Œgetå’Œput()è°ƒç”¨Close()æ–¹æ³•è¿›å…¥è¿æ¥ç»ˆæ­¢é˜¶æ®µï¼ˆå››æ¬¡æ¡æ‰‹ï¼‰åï¼Œå®¢æˆ·ç«¯çŠ¶æ€åˆ™ä¼šè¿›å…¥TIME_WAITçŠ¶æ€\n\n\nç­‰å¾…2MSLåï¼Œå®¢æˆ·ç«¯Closeã€‚\n\nå¦‚æœå¸Œæœ›å¯¹TCPçš„è®¾è®¡æƒ³è¦æ›´æ·±å…¥äº†è§£ï¼Œå¯ä»¥å‚è€ƒ  \n\nä¸ºä»€ä¹ˆ TCP åè®®æœ‰ TIME_WAIT çŠ¶æ€  \nä¸ºä»€ä¹ˆ TCP å»ºç«‹è¿æ¥éœ€è¦ä¸‰æ¬¡æ¡æ‰‹  \nWhy is the TCP connection terminated in a 4-way handshake?\n\n\nREFERENCE[1] 6.824 kv.go[2] ç»´åŸºç™¾ç§‘  \n","categories":["è®¡ç®—æœºç½‘ç»œ"],"tags":["go","network","socket","tcp"]},{"title":"ä¸¤ç§ç¿»è½¬sliceçš„æ–¹å¼å¯¹æ¯”","url":"/2021/04/16/two-way-to-reverse-slice/","content":"åˆ·é¢˜æ—¶ï¼Œé‡åˆ°ä¸€ä¸ªéœ€æ±‚å¦‚ä¸‹ï¼šå¯¹ä¸€ä¸ªsliceè¿›è¡Œç¿»è½¬ã€‚åœ¨å®ç°çš„è¿‡ç¨‹ä½¿ç”¨äº†ä¸¤ç§æ–¹å¼ï¼š\n\næ¯æ¬¡æ’å…¥æ–°å…ƒç´ æ—¶ï¼Œä½¿ç”¨appendå·¦æ’å…¥çš„æ–¹å¼\nå…ˆæ­£å¸¸appendå³æ’å…¥ï¼Œæœ€åå†å¯¹è¿™ä¸ªsliceè¿›è¡Œç¿»è½¬\n\n\n\nä¸¤ç§æ–¹å¼çš„å®ç°åŠæ—¶é—´å’Œç©ºé—´æ¶ˆè€—çš„å¯¹æ¯”å®ç°ä¸‹é¢ä¸¤ä¸ªæ–¹æ³•å®ç°çš„åŠŸèƒ½æ˜¯ä¸€è‡´çš„\n\næ–¹æ³•1ä½¿ç”¨å·¦æ’å…¥æ³•æ¥å®ç°ç¿»è½¬ï¼Œå¦‚ä¸‹æ‰€ç¤º\nfunc method1() &#123;    result := make([][]int, 0)    for i := 0; i &lt; 100; i++ &#123;        item := make([]int, 0)        for j := 0; j &lt; 10; j++ &#123;            item = append(item, i*j)        &#125;        // å·¦æ’å…¥        join := [][]int&#123;item&#125;        result = append(join, result...)    &#125;&#125;\næ–¹æ³•2å…ˆæ­£å¸¸appendï¼Œå†ç¿»è½¬\nfunc method2() &#123;    result := make([][]int, 0)    for i := 0; i &lt; 100; i++ &#123;        item := make([]int, 0)        for j := 0; j &lt; 10; j++ &#123;            item = append(item, i*j)        &#125;        result = append(result, item)    &#125;    tmp := result    result = make([][]int, 0)    for i := len(tmp) - 1; i &gt;= 0; i-- &#123;        result = append(result, tmp[i])    &#125;&#125;\n\næ€§èƒ½å¯¹æ¯”\næ—¶é—´\ngoos: darwingoarch: amd64BenchmarkMethod1-4         17006             69558 ns/opBenchmarkMethod2-4         43002             27851 ns/op\næ—¶é—´ä¸Šï¼Œæ–¹æ³•2è¦å¥½äºæ–¹æ³•1\n\nç©ºé—´\n\n\n\nç©ºé—´ä¸Šï¼Œæ–¹æ³•2ä¹Ÿè¦ä¼˜äºæ–¹æ³•1\nåˆ†æé€šè¿‡pprofå·¥å…·å¯¹å…¶æºç è¿›è¡Œåˆ†æå¦‚ä¸‹\nä»ä¸Šå›¾æˆ‘ä»¬å‘ç°ï¼Œresult = append(join, result...)è¯­å¥çš„å†…å­˜æ¶ˆè€—éå¸¸ä¸¥é‡ï¼ŒåŒæ—¶è¿™ç§æ–¹æ³•è¿›è¡Œappendï¼Œä¼šä½¿å¾—åœ°å€é‡æ–°åˆ†é…ï¼ˆå› ä¸ºé¦–åœ°å€æ”¹å˜äº†ï¼‰è‡´ä½¿å¤šä½™å†…å­˜å’Œæ—¶é—´çš„æ¶ˆè€—ã€‚\nè¡¥å……æ–¹æ³•2çš„ç¿»è½¬å¯ä»¥æœ‰ä¸¤ç§æ–¹æ³•å®ç°\n\nå¦‚ä¸Šé¢æ‰€ç¤ºï¼Œé€šè¿‡sliceåå‘éå†æ’å…¥å®Œæˆç¿»è½¬\nè¿˜å¯ä»¥é€šè¿‡åŒæŒ‡é’ˆæ³•æ¥ç¿»è½¬\n\nè¿™é‡Œé€šè¿‡ä¸€ä¸ªç®€å•ä¾‹å­æ¯”è¾ƒä¸‹åŒæ–¹çš„æ€§èƒ½\nfunc method1() &#123;    var input = make([]int, 0, 100)    for i := 0; i &lt; len(input); i++ &#123;        input = append(input, i)    &#125;    // method1    for i := 0; i &lt; len(input)/2; i++ &#123;        j := len(input) - 1 - i        input[i], input[j] = input[j], input[i]    &#125;&#125;func method2() &#123;    var input = make([]int, 0, 100)    for i := 0; i &lt; len(input); i++ &#123;        input = append(input, i)    &#125;    // method2    tmp := input    input = make([]int, 0, 100)    for i := len(tmp) - 1; i &gt;= 0; i-- &#123;        input = append(input, tmp[i])    &#125;&#125;\nç»“æœè¡¨ç¤ºï¼ŒåŒæŒ‡é’ˆæ³•ä¼šæ›´å¥½ä¸€äº›ï¼Œç†ç”±å¾ˆç®€å•ï¼Œå› ä¸ºåŒæŒ‡é’ˆæ˜¯O(N/2)çš„\n$ go test -run=. -bench=. -benchmemgoos: darwingoarch: amd64BenchmarkMethod1-4      71840024                16.9 ns/op             0 B/op          0 allocs/opBenchmarkMethod2-4      26362216                39.7 ns/op             0 B/op          0 allocs/opPASS\n\n\nç»“è®ºè¿™ç§æƒ…å†µä¸‹æ¨èä½¿ç”¨æ–¹æ³•2ï¼ŒåŒæ—¶å¯¹äºæ–¹æ³•1(å·¦æ’å…¥)çš„ä½¿ç”¨è¦æ ¼å¤–è°¨æ…ï¼Œä¸å½“çš„ä½¿ç”¨ä¼šä½¿å¾—ç¨‹åºçš„æ—¶/ç©ºé—´æ¶ˆè€—åŠ å‰§ã€‚\n\nå¦‚æœæœ‰æ›´å¥½çš„å®ç°æ–¹å¼ï¼Œæˆ–è€…å¯¹ä¸Šè¿°ç¨‹åºæœ‰æ›´å¥½çš„å»ºè®®ï¼Œæ¬¢è¿ä¸‹æ–¹è¯„è®º~\n\n","categories":["Golang"],"tags":["go"]}]