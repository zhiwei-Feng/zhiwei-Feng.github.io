[{"title":"2021年个人总结","url":"/2022/01/01/2021summary/","content":"2021年个人总结2021年就这样悄悄过去了，回首这一年，感觉遗憾多于收货，苦闷大于幸福吧。这也是第一次做这样一个个人的年度总结，希望能将这个习惯延续下去，花短短的几个小时来对过去一年自己的表现进行自评还是很有意义的，下面就开始吧。\n上半年应该说整个上半年是陷入了松懈的陷阱了，这一点并不是说我把心思花在玩儿或者什么其他的事情上了，而是单纯地在自己应该做的事情上变得低效。首先上半年是个人从研一到研二的上半截的一个过程吧，这个阶段其实科研任务是比较繁重、又有一堆课程和导师助教的任务，所以其实在一天时间里是有碎片化，比较常见的状态就是上午刚弄完助教的事情，然后下午就要上课，晚上再继续回实验室搞实验。助教的过程中因为一些录课方面的要求其实基本上是没有时间去分给其他的事情的（想去写写代码啥的，但是每5分钟就要抬头去拍照并发到课程群，实在是低效，到后期就演变为随便看点东西混了）。而下午一般研究生的课倒还是不错的，可以做做自己的事情，当然其实后面因为一些原因，在某些课程任务比较重，而组员又几乎的摆烂的情况下，我也全权负责了一个小组整个课程的所有作业，包括期末的project，这一点其实也耗费了我平时比较多的时间吧。\n最后说说让我觉得掉入松懈陷阱的最直接源头：科研实验。说实话，最初还是想好好在科研这条路上做点东西出来的，结果导师的一言堂和毫无实操根据的想法，磨灭了我对科研或者说是算法的兴趣吧，其实我也清楚企业里的算法工程会实实在在的多，也更有趣的多（因为我对能够落地能够应用产生价值的东西有天生的好感）。但是可能和心态有关吧，在和导师疯狂拉扯的过程中，我也从最开始不停思考可以解决难题的点（当然一般来说是不work，即便work，也常常会被老师说没什么创新点），到最后变得为了加一些所谓的创新点而脱离了对实际问题的思考。心态的转变也让我没有动力去做更多的思考，成为了无情的调参侠，而调参的过程也因为导师机器资源的匮乏而变得如此的漫长，动辄就是训练一轮需要一周。现在看来，这个机械的调参过程实际上让个人的成长是停滞的。这样的事情每天重复上演，最后我硬生生把性能调上去了一些，想着准备写成论文给这个工作画个句号，结果导师一句：”我觉得你这个工作太单薄了，还要加点东西，但我还没想好怎么加，你也再想想”，就把我打发了。就这样我结束了上半年，期间陆陆续续也刷了些leetcode。\n下半年下半年的开始，基本上延续了上半年的东西，继续找想法和做实验，进度当然很慢，但总归是慢慢在推进的。这个关节口，来了个项目申报的事情，原以为这个事情会很快就结束，因为计划是20来天就结束的，结束最后硬是耗了100天左右，这个过程非常的痛苦，每天不是开会就是改文档，做ppt，毫无个人时间，而且过着706（早上7点到晚上12点）的生活，身心俱疲。但是想着如果项目申请下来就可以给后面的学弟学妹创造良好的科研条件，总归是有个奔头在做这个事情。这期间，因为合作的公司单位经常性的在工作推进上拖沓，导致很多事情都落到了我们头上，难上加难。到最后项目申报的结果当然不会是那句童话”努力就会有回报”所说的拉，很无力的失败了。这一下就到了10月份中旬了，失败归失败，生活还要继续不是吗，我整理自己要做的事情，因为明年就要投入到毕业和找工作的事情中了，所以要为此做好准备，刷题、基础知识复习和个人项目的准备都要在路上了。与此同时，科研实验也不能落下，事情还是比较多的，从这之后，效率相对还是好一些了，到了现在，刷题也有了一些效果（下图），基础知识复习也落实一些，个人项目也在准备中，总的来说还是比较充实的。因为毕业个人目标是在研发岗而不是算法岗，所以在科研实验和工作准备两个路上得做更多的权衡。\n\n\n明年计划首先肯定是比较好好利用这个寒假拉，2月底就要开始暑期实习的招聘了，寒假算是最后一波冲刺了，准备计划其实也没什么特殊的，还是老三样吧，算法的每日保持、网络和系统相关知识的复习（目前看完了《网络是怎样连接的》这本书）、个人项目（商品秒杀为核心的系统，后续做一下6.824的lab）。\n个人软实力的缺陷，在多任务环境下的负载能力还需要加强，往往每天要做3到4件事情的时候，比较容易出现切换耗时太久了，同时个人作息也是有大问题，每天凌晨3，4点才睡觉，太影响白天的状态了，新的一年争取调整到2点以前睡觉吧。\n就写这么多吧，啰啰嗦嗦说了一堆，希望明年这个时候也毕业了，工作也应该有了，希望到时候是对自己满意的这么个状态吧。\n","categories":["生活"]},{"title":"slice使用append的小坑","url":"/2021/04/22/be-careful-when-use-append-to-add-slice-to-slice/","content":"今天在刷一道算法题的时候遇到了一个关于slice在使用append的小细节问题。这个算法题可以参考路径总和II。题意很简单，就是从一个二叉树中所有由根到叶子节点的路径中找到所有的满足路径和等于target的路径。\n\n\n问题在参考官方题解的golang版本的时候，发现了有一段代码是我一开始没弄明白的。完整代码可参考\nfunc pathSum(root *TreeNode, targetSum int) (ans [][]int) &#123;    path := []int&#123;&#125;    var dfs func(*TreeNode, int)    dfs = func(root *TreeNode, left int) &#123;        if root == nil &#123;            return        &#125;        left -= root.Val        path = append(path, root.Val)        defer func() &#123; path = path[:len(path)-1] &#125;()        if left == 0 &amp;&amp; root.Left == nil &amp;&amp; root.Right == nil &#123;            ans = append(ans, append([]int&#123;&#125;, path...))            return        &#125;        dfs(root.Left, left)        dfs(root.Right, left)    &#125;    dfs(root, targetSum)    return&#125;\n其中的ans = append(ans, append([]int&#123;&#125;, path...))则是我关注的地方，一开始我疑惑为什么不直接ans = append(ans, path))，但是实验证明结果会非常奇怪，比如对于这样一个例子我们想要的是[[5,4,11,2],[5,8,4,5]]，但是实际上是[[5,8,4,1],[5,8,4,1]].  \n解析这里其实是我忘了golang中的slice底层实现如下图所示\ntype slice struct &#123;    array unsafe.Pointer    len   int    cap   int&#125;\n因此如果像ans = append(ans, path))这样做，其实在ans存放的是path这个slice，在后续代码运行中的改变会导致ans的结果改变，从而产生一个错误的结果。而ans = append(ans, append([]int&#123;&#125;, path...))则是在ans中存放了一个path的副本，且该副本不会被其他代码修改到。因此结果才是正确的。\n\n一行代码就揭示golang中slice的本质~，真实妙啊。\n\nREFERENCE[1] leetcode 113题[2] 深入解析 Go 中 Slice 底层实现\n","categories":["Golang"],"tags":["go","指针"]},{"title":"Gorm加悲观锁的最新用法","url":"/2021/11/30/gorm-for-update/","content":"因为google了“gorm for update”或者是“gorm 开启排他锁”出来的文章清一色的使用着如下用法来开启表的行/表锁  \ntx.Set(&quot;gorm:query_option&quot;, &quot;FOR UPDATE&quot;).First(&amp;employee, id)\n\n但是经过测试，我加了没有作用，搜索gorm官方文档，结果用法已经变成如下\ndb.Clauses(clause.Locking&#123;Strength: &quot;UPDATE&quot;&#125;).Find(&amp;users)// SELECT * FROM `users` FOR UPDATEdb.Clauses(clause.Locking&#123;  Strength: &quot;SHARE&quot;,  Table: clause.Table&#123;Name: clause.CurrentTable&#125;,&#125;).Find(&amp;users)// SELECT * FROM `users` FOR SHARE OF `users`\n\n果然有问题先找官方文档。😂\n","categories":["Golang"],"tags":["go","gorm"]},{"title":"[6.824系列] Outline of lab1 solution","url":"/2022/04/10/outline-of-6-824-lab1-solution/","content":"本文主要总结了如何实现6.824 lab1的大纲, 方便自己和读者能够迅速理解MapReduce具体要实现些什么.\n\n概览首先整个MapReduce的过程可以参考下图, 分为两个阶段: Map和Reduce阶段.从这个图中我们可以总结出MapReduce整体的工作流程如下\n\n将任务的输入文件拆分多个split文件\n创建多个Map任务, 每个任务对应输入若干个split\n在多个worker服务器上执行Map任务, 并将输出写入到Intermediate files中\n当所有Map完成后, MapReduce进入Reduce阶段, 为多个worker服务器分配Reduce任务\n每个Reduce任务读取对应的Intermediate files完成Reduce任务, 并将输出写入对应的output files\n\n问题Q1: 什么时候由谁来对任务输入文件进行split? 如何split?\nA: 由Master在MapReduce任务初始化的过程完成, split的目的是为了将一个任务拆分成多个子任务给到多个worker机器运行, 实现并发加速, 因此split文件的数量应该等同于worker机器数量来设置. 同时split应该按照预设好的文件的大小来进行划分(比如一个split文件为1KB大小). \n\nQ2: Map是什么?\nA: 接收一个key/value的pair, 产生一系列的key/value中间结果的过程就是Map, 比如说下面是一个wordcount的map例&gt; 子\nmap(String key, String value):    // key: document name    // value: document contents    for each word w in value:        EmitIntermediate(w, &quot;1&quot;);\n\nQ3: Reduce怎么知道自己对应的是哪些Intermediate files?\nA: 我们把对Map产生的每一个key/value, 对key进行hash后分配到一个Reduce任务, 具体来说:\n\n给定一个Map任务X以及产生的key/value pair\nReduce Y = hash(key) % nReduce\nwrite to “mr-X-Y” file因此, 对于给定的Reduce任务Y, 它去读取所有的mr-?-Y文件作为输入.\n\n\nQ4: 如何处理Map任务或者Reduce任务执行超时或失败的问题\nA: 利用超时机制和Master被动分配任务来实现超时重试, 对每一个任务都记录其开始的时间, 当worker请求分配任务的时候, 遍历所有的任务判断是否超时, 如果超时则是一个可以被分配的任务.\n\n实现大纲大纲可以分为两个部分: Master和Worker\nWorker对于每一个Worker, 它的执行过程都可以概括为:无限循环请求任务分配并执行直至MapReduce全部任务完成. 过程如下:\n\n向Master申请分配任务(由Master决定分配Map还是Reduce任务)\n如果Master返回MapReduce已经全部完成则退出循环\n根据返回的任务类型(Map or Reduce)执行对应的处理过程\n重复上述\n\nMap处理Map的输入: taskId(任务ID), nReduce(预设的Reduce个数), fileName(输入文件的访问路径)\n\n这里需要注意fileName的定义, 在这个作业当中, 我们可以直接使用文件名作为fileName, 这是因为程序跑在单机环境下, 通过多个进程的形式模拟分布式环境, 因此默认情况下相关文件都存放在主程序的当前目录下, 因此可以通过文件名即可以访问到, 但是在生产环境, 我们往往会依托一个分布式文件系统来存放这些文件(比如GFS), 因此此时fileName应该是一个文件访问URL, 可以通过URL去分布式文件系统读取到对应文件. \n\nMap的过程\n\n读取文件内容并经map函数处理得到对应kv对集合kva\n创建nReduce个临时文件\n将kva按照key hash值写入到对应临时文件\n重命名临时文件为mr-X-Y, X为taskId(mapId), Y为reduceId.\n通知Master, 该任务完成\n\n\n这里采用约定大于配置思想, 因此不需要通知Master该任务输出文件的文件名, 但是如果是分布式文件系统的话需要给出系统接口返回的文件URL给Master.\n\nReduce处理过程和Map处理类似Reduce的输入: taskId, intermediateFileNames(中间文件访问路径的集合)\nReduce的过程\n\n遍历读取中间文件, 并保存到一个内存的列表中\n按照key来排序列表\n将列表中每一个key和对应的value集合交给reduce函数处理\n结果写入到临时文件并重命名\n通知Master任务完成\n\nMasterMaster作为MapReduce的协调者, 需要对所有Map、Reduce任务的状态进行管理, 同时在对应的状态下进行任务分配. 总的来说需要具备以下功能:\n\n任务初始化\n任务分配\n任务完成处理\n\n任务初始化这一过程实际上也是Master的初始化过程. 这一过程, Master需要设定好需要多少个Reduce和Map, 同时对相应的Map和Reduce任务进行初始化, 同时进入整个MapReduce进入Mapping状态.\n任务分配这个过程核心在于判断当前MapReduce(Master)处于什么状态从而分配相应的任务:\n\n如果处于Mapping状态, 遍历MapTasks列表判断每一个任务是否可以被分配\n判断该任务是否超时, 如果超时则需要将其状态修改为可被分配\n\n\n如果处于Reducing状态, 遍历ReduceTasks列表进行类似的分配\n如果处于Done状态, 则返回Exit状态码给worker告知整个MapReduce已经结束\n\n任务完成处理\n给定完成的任务ID: taskId\n根据阶段Mapping/Reducing找到对应的Task\n修改Task的状态为Finished\n如果该阶段所有任务都已经完成,则推进Master的状态到下一阶段\n\n\n\n","categories":["6.824"],"tags":["go","分布式"]},{"title":"面试16种代码模式总结(1) - 滑动窗口","url":"/2021/04/04/sliding-window/","content":"本系列文章是对Grokking the Coding Interview: Patterns for Coding Questions课程的总结，编程语言使用Go。读者如果想要更细致的了解，请自行购买课程学习。\n问题背景在处理数组和链表的时候，我们经常会需要找出满足某些条件的连续子列, 比如子列的和最大等，这个时候就可以使用滑动窗口的思想来进行解答。这里注意的是子列可以是固定大小也可以是可变大小，两种情况有相应的处理方式。\n\n\n下面先给出一个例子，比如在给定一个数组，找出其中每个size为K的连续子列的平均值。  \nArray: [1, 3, 2, 6, -1, 4, 1, 8, 2], K=5Output: [2.2, 2.8, 2.4, 3.6, 2.8]\n\n滑动窗口的解决方案如下:\nfunc findAveragesOfSubArraysBySlidingWindow(K int, arr []int) []float64 &#123;    results := make([]float64, len(arr)-K+1)    windowSum := 0    windowStart := 0    for windowEnd := 0; windowEnd &lt; len(arr); windowEnd++ &#123;        // 把下个元素加上        windowSum += arr[windowEnd]        // 滑动窗口，特别地，如果没有达到K个则不滑动        if windowEnd &gt;= K-1 &#123;            // 当前windowSum计算了整个窗口的和            results[windowStart] = float64(windowSum) / float64(K)            // 当前窗口计算完后，移动窗口需要先减去原来窗口头部的元素            windowSum -= arr[windowStart]            windowStart++        &#125;    &#125;    return results&#125;\n\n解法总结根据窗口大小是否固定，分为固定大小和可变大小\n固定大小这里拿 找出size=k的最大连续子序列和 作为例子\nGiven an array of positive numbers and a positive number k,find the maximum sum of any contiguous subarray of size k.Input: [2, 1, 5, 1, 3, 2], k=3Output: 9Explanation: Subarray with maximum sum is [5, 1, 3].Input: [2, 3, 4, 1, 5], k=2Output: 7Explanation: Subarray with maximum sum is [3, 4].\n\n解决方案\nfunc max(x, y int) int &#123;    if x &gt; y &#123;        return x    &#125; else &#123;        return y    &#125;&#125;func solution(arr []int, k int) int &#123;    var (        windowStart = 0        windowSum = 0 // 用于记录当前窗口的状态        maxSum = 0 // 用于记录最好的状态    )    for windowEnd:=0;windowEnd&lt;len(arr);windowEnd++&#123;        // 这一步是窗口的右侧进行一格扩张，同时更新当前窗口的状态        windowSum += arr[windowEnd]        // 判断当前窗口是否满足相应条件        if windowEnd &gt;= k-1&#123;            // 更新最好的状态            maxSum = max(maxSum, windowSum)            // 收缩窗口左侧            windowSum -= arr[windowStart]            windowStart--        &#125;    &#125;    return maxSum&#125;\n\n\n相关练习: [1][2][3]\n\n可变大小这里通过长度最小的子数组来说明\nfunc min(i, j int) int &#123;    if i&lt;j &#123;        return i    &#125;else&#123;        return j    &#125;&#125;func minSubArrayLen(target int, nums []int) int &#123;    var(        windowStart = 0        windowSum = 0        minSize = -1    )    for windowEnd:=0;windowEnd&lt;len(nums);windowEnd++&#123;        // 窗口右侧扩张，这个部分和固定大小是一样的        windowSum+=nums[windowEnd]        // 这个部分是与固定大小类型最大的区别        // 不同于固定大小每次的右侧扩张和左侧收缩是同步的        // 可变大小的左侧收缩需要循环判断窗口是否满足条件        // 可能右侧扩张了很多次，但是左侧才收缩一回        // 也可能右侧扩张一次，左侧需要收缩几回        for windowSum&gt;=target&#123;            if minSize==-1&#123;                minSize = windowEnd-windowStart+1            &#125;else&#123;                minSize = min(minSize, windowEnd-windowStart+1)            &#125;             windowSum-=nums[windowStart]            windowStart++        &#125;        // 对于一些情况条件需要进行后处理，比如当收缩窗口直到窗口内单一字符数量&lt;k        // 然后再比较当前窗口的大小    &#125;    if minSize==-1&#123;        return 0    &#125;    return minSize&#125;\n\n\n相关练习题: [1][2][3][4][5][6][7]\n\n特殊例子最小覆盖子串原题见leetcode\nfunc findSubstring(str, pattern string) string &#123;    // 边界     if len(pattern)&gt;len(str)&#123;        return &quot;&quot;    &#125;    var (        windowStart = 0        matched     = 0        minLength   = len(str) + 1        subStrStart = 0        patternMap  = make(map[byte]int)    )    for i := 0; i &lt; len(pattern); i++ &#123;        patternMap[pattern[i]]++    &#125;    for windowEnd := 0; windowEnd &lt; len(str); windowEnd++ &#123;        wright := str[windowEnd]        if _, ok := patternMap[wright]; ok &#123;            patternMap[wright]--             // 关键点1, 不再是==0，而是&gt;=0，因为包含所有的字符            if patternMap[wright] &gt;= 0 &#123;                matched++            &#125;        &#125;        // 如果当前window包含pattern所有的字符，则从左收缩窗口至不完全包含状态         // 注意这里等号右侧不是len(patternMap)，因为是要匹配所有字符        for matched == len(pattern) &#123;             if minLength &gt; windowEnd-windowStart+1 &#123;                minLength = windowEnd - windowStart + 1                subStrStart = windowStart            &#125;            wleft := str[windowStart]            if _, ok := patternMap[wleft]; ok &#123;                // 关键点2，只要有一个匹配的字符移除了窗口，则停止收缩                if patternMap[wleft] == 0 &#123;                    matched--                &#125;                patternMap[wleft]++            &#125;            windowStart++        &#125;    &#125;    if minLength &gt; len(str) &#123;        return &quot;&quot;    &#125; else &#123;        return str[subStrStart : subStrStart+minLength]    &#125;&#125;\nFAQ: 这里对上述代码做一定的解释，主要困惑点在于两个关键点Q: 为什么关键点1处是&gt;=0？A: 因为是要匹配所有的字符，因为每遇到一个需要匹配的字符，我们都需要对patternMap中对应值做减法并matched++, 直到我们匹配完了pattern所有该字符，此时对于多余该字符我们只需要更新patternMap，但是不必再更新matched。\nQ: 为什么关键点2处是==0？A: 这里注意，如果窗口同一个字符没有冗余，那么移除了一个该字符则意味着匹配不完全，但是如果窗口内该字符有冗余，比如pattern是aab，而窗口内有3个a，此时a有冗余，如果收缩窗口只移出了一个a，那么此时窗口依然是满足匹配完全条件的，反映到代码上，收缩前patternMap[&#39;a&#39;] = -1 (在2的基础-3)，收缩后patternMap[&#39;a&#39;]=0，因此如果收缩掉下一个a，则需要matched–了。\n串联所有单词的子串原题见leetcode这个题目主要要对题意理解清楚，首先目标子串需要满足几个条件：\n\n长度等于单词列表中的每个单词长度*单词个数\n子串不可以出现不在列表上的其他单词\n\nfunc findWordConcatenation(str string, words []string) []int &#123;    if len(words)==0||len(str)==0&#123;        return []int&#123;&#125;    &#125;    var (        wordFreqMap = make(map[string]int)        wordsCount  = len(words)        wordLength  = len(words[0])        // 存储满足条件的index        startIndex  = make([]int, 0, 10)     )    // 记录每个单词出现的频率    for _, v := range words &#123;        wordFreqMap[v]++    &#125;    // 注意这个不是常规的sliding window pattern     // i表示的是一个子串的起始位置，从条件可知每个子串是固定长度的     // 所以i最大为len(str)-wordLength*wordsCount    for i := 0; i &lt;= len(str)-wordLength*wordsCount; i++ &#123;        wordsSeenMap := make(map[string]int) // key1: 保存看过的word的数量        // 对从当前index i开始的长度为wordLength*wordsCount的string进行判定        for j := 0; j &lt; wordsCount; j++ &#123;            nextWordIndex := i + j*wordLength // 当前word的开始index            word := str[nextWordIndex : nextWordIndex+wordLength]            // 如果出现不在words数组中的word，则直接跳出            if _, ok := wordFreqMap[word]; !ok &#123;                break            &#125;            wordsSeenMap[word]++             // 如果words数组中某个word数量出现次数过多意味着一定会有其他单词不在，则也直接跳出            if wordsSeenMap[word] &gt; wordFreqMap[word] &#123;                break            &#125;            // 如果遍历到该string的最后一个字符都没跳出循环，意味该string是满足条件的            if j == wordsCount-1 &#123;                startIndex = append(startIndex, i)            &#125;        &#125;        // ===end===    &#125;    return startIndex&#125;\n\n\nREFERENCE[1] https://www.educative.io/courses/grokking-the-coding-interview[2] https://github.com/zhiwei-Feng/Golang-Grokking-the-Coding-Interview-Patterns-for-Coding-Questions\n","categories":["面试","16种代码模式"],"tags":["go","algorithm","sliding window"]},{"title":"从6.824的kv.go理解tcp协议","url":"/2021/04/11/socket-analysis-for-6-824-kv-go/","content":"本文是在学习6.824课程时，对Lec 2的kv.go产生的困惑的解释和总结。\n\n\nkv.go首先对kv.go的情况进行解释。这里只会取一些重点片段进行解释，需要\b了解完整代码细节的，读者可自行选择文章最后的参考条目进行详细了解。\n主逻辑func main() &#123;    //启动rpc服务，一个kv存储    server()     //写入一个kv键值对    put(&quot;subject&quot;, &quot;6.824&quot;)    fmt.Printf(&quot;Put(subject, 6.824) done\\n&quot;)    //读出刚才存储的key的value    fmt.Printf(&quot;get(subject) -&gt; %s\\n&quot;, get(&quot;subject&quot;))&#125;\n主逻辑非常简单，启动一个kv存储的rpc服务，然后运行简单的读写功能测试。\nserver()func server() &#123;    kv := new(KV)    kv.data = map[string]string&#123;&#125;    rpcs := rpc.NewServer()    rpcs.Register(kv)    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)    if e != nil &#123;        log.Fatal(&quot;listen error:&quot;, e)    &#125;    go func() &#123;        for &#123;            conn, err := l.Accept()            if err == nil &#123;                go rpcs.ServeConn(conn)            &#125; else &#123;                break            &#125;        &#125;        l.Close()    &#125;()&#125;\n启动服务，监听1234端口，并开始接受客户端的连接\nclientfunc get(key string) string &#123;    client := connect()    args := GetArgs&#123;key&#125;    reply := GetReply&#123;&#125;    err := client.Call(&quot;KV.Get&quot;, &amp;args, &amp;reply)    if err != nil &#123;        log.Fatal(&quot;error:&quot;, err)    &#125;    client.Close()    return reply.Value&#125;func put(key string, val string) &#123;    client := connect()    args := PutArgs&#123;key, val&#125;    reply := PutReply&#123;&#125;    err := client.Call(&quot;KV.Put&quot;, &amp;args, &amp;reply)    if err != nil &#123;        log.Fatal(&quot;error:&quot;, err)    &#125;    client.Close()&#125;\n客户端方法总体逻辑是一致，首先进行tcp连接的建立，然后进行rpc方法调用，最后关闭连接\n解析过程如果你运行该程序，会发现打印如下：\n$ go run kv.goPut(subject, 6.824) doneget(subject) -&gt; 6.824$\n\n为什么程序最后会退出，而不是因为server在监听阻塞住。我自己的解释是：首先是因为server()中的无限接收请求的循环是运行在goroutine当中，所以之后的客户端请求可以并发的运行；其次因为主线程没有其他方法的阻塞，所以会在所有逻辑结束后退出，也意味该进程退出了，这样其中的所有线程都会结束，包括其中创建的goroutine。\n如果读者有更好的解释欢迎留言讨论。\n\n在该程序的主逻辑中，实际发生了两次tcp连接，我们知道一次tcp协议的运行过程有三个阶段：连接创建、数据传送和连接终止。server()下开启的rpc服务监听着1234端口，而get和put()中的connect()则完成一次tcp连接创建的三次握手，如图下\n\n此时通过netstat命令查看会出现有两个连接以及一个监听  \n\n当数据传送完毕，get和put()调用Close()方法进入连接终止阶段（四次握手）后，客户端状态则会进入TIME_WAIT状态\n\n\n等待2MSL后，客户端Close。\n\n如果希望对TCP的设计想要更深入了解，可以参考  \n\n为什么 TCP 协议有 TIME_WAIT 状态  \n为什么 TCP 建立连接需要三次握手  \nWhy is the TCP connection terminated in a 4-way handshake?\n\n\nREFERENCE[1] 6.824 kv.go[2] 维基百科  \n","categories":["计算机网络"],"tags":["go","network","socket","tcp"]},{"title":"两种翻转slice的方式对比","url":"/2021/04/16/two-way-to-reverse-slice/","content":"刷题时，遇到一个需求如下：对一个slice进行翻转。在实现的过程使用了两种方式：\n\n每次插入新元素时，使用append左插入的方式\n先正常append右插入，最后再对这个slice进行翻转\n\n\n\n两种方式的实现及时间和空间消耗的对比实现下面两个方法实现的功能是一致的\n\n方法1使用左插入法来实现翻转，如下所示\nfunc method1() &#123;    result := make([][]int, 0)    for i := 0; i &lt; 100; i++ &#123;        item := make([]int, 0)        for j := 0; j &lt; 10; j++ &#123;            item = append(item, i*j)        &#125;        // 左插入        join := [][]int&#123;item&#125;        result = append(join, result...)    &#125;&#125;\n方法2先正常append，再翻转\nfunc method2() &#123;    result := make([][]int, 0)    for i := 0; i &lt; 100; i++ &#123;        item := make([]int, 0)        for j := 0; j &lt; 10; j++ &#123;            item = append(item, i*j)        &#125;        result = append(result, item)    &#125;    tmp := result    result = make([][]int, 0)    for i := len(tmp) - 1; i &gt;= 0; i-- &#123;        result = append(result, tmp[i])    &#125;&#125;\n\n性能对比\n时间\ngoos: darwingoarch: amd64BenchmarkMethod1-4         17006             69558 ns/opBenchmarkMethod2-4         43002             27851 ns/op\n时间上，方法2要好于方法1\n\n空间\n\n\n\n空间上，方法2也要优于方法1\n分析通过pprof工具对其源码进行分析如下\n从上图我们发现，result = append(join, result...)语句的内存消耗非常严重，同时这种方法进行append，会使得地址重新分配（因为首地址改变了）致使多余内存和时间的消耗。\n补充方法2的翻转可以有两种方法实现\n\n如上面所示，通过slice反向遍历插入完成翻转\n还可以通过双指针法来翻转\n\n这里通过一个简单例子比较下双方的性能\nfunc method1() &#123;    var input = make([]int, 0, 100)    for i := 0; i &lt; len(input); i++ &#123;        input = append(input, i)    &#125;    // method1    for i := 0; i &lt; len(input)/2; i++ &#123;        j := len(input) - 1 - i        input[i], input[j] = input[j], input[i]    &#125;&#125;func method2() &#123;    var input = make([]int, 0, 100)    for i := 0; i &lt; len(input); i++ &#123;        input = append(input, i)    &#125;    // method2    tmp := input    input = make([]int, 0, 100)    for i := len(tmp) - 1; i &gt;= 0; i-- &#123;        input = append(input, tmp[i])    &#125;&#125;\n结果表示，双指针法会更好一些，理由很简单，因为双指针是O(N/2)的\n$ go test -run=. -bench=. -benchmemgoos: darwingoarch: amd64BenchmarkMethod1-4      71840024                16.9 ns/op             0 B/op          0 allocs/opBenchmarkMethod2-4      26362216                39.7 ns/op             0 B/op          0 allocs/opPASS\n\n\n结论这种情况下推荐使用方法2，同时对于方法1(左插入)的使用要格外谨慎，不当的使用会使得程序的时/空间消耗加剧。\n\n如果有更好的实现方式，或者对上述程序有更好的建议，欢迎下方评论~\n\n","categories":["Golang"],"tags":["go"]}]